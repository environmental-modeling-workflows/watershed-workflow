<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>watershed_workflow.river_mesh &mdash; Watershed Workflow 1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=f2a433a1"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Watershed Workflow
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/mesh_coweeta.html">Example: mesh a delineated watershed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../concepts.html">Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gallery.html">Gallery</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Watershed Workflow</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../watershed_workflow.html">watershed_workflow</a></li>
      <li class="breadcrumb-item active">watershed_workflow.river_mesh</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for watershed_workflow.river_mesh</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;creates river mesh using quad, pentagon and hexagon elements&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">shapely.geometry</span>
<span class="kn">import</span> <span class="nn">shapely.ops</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">ConvexHull</span>

<span class="kn">import</span> <span class="nn">watershed_workflow.utils</span>
<span class="kn">import</span> <span class="nn">watershed_workflow.tinytree</span>
<span class="kn">import</span> <span class="nn">watershed_workflow.plot</span>


<div class="viewcode-block" id="IntersectionError">
<a class="viewcode-back" href="../../mesh.html#watershed_workflow.river_mesh.IntersectionError">[docs]</a>
<span class="k">class</span> <span class="nc">IntersectionError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span></div>



<span class="k">def</span> <span class="nf">_indexPointInSeg</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.e-2</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">[:]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="n">ind</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(((</span><span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">[:])),</span>
                     <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">ip</span><span class="p">:</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">ip</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">point</span><span class="p">))</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ind</span>


<div class="viewcode-block" id="sort_children_by_angle">
<a class="viewcode-back" href="../../mesh.html#watershed_workflow.river_mesh.sort_children_by_angle">[docs]</a>
<span class="k">def</span> <span class="nf">sort_children_by_angle</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sorts the children of a given segment by their angle with respect to that segment.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">preOrder</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># compute tangents</span>
            <span class="n">my_seg_tan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span> <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                <span class="n">tan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">return</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">my_seg_tan</span><span class="p">,</span> <span class="n">tan</span><span class="p">)</span>

            <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">angle</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">_isOverlappingCorridor</span><span class="p">(</span><span class="n">corr</span><span class="p">,</span> <span class="n">river</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">corr</span><span class="o">.</span><span class="n">interiors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># there is an overlap upstream of the junction of two tributaries,</span>
        <span class="c1"># creating a hole</span>
        <span class="k">return</span> <span class="mi">2</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_isExpectedNumPoints</span><span class="p">(</span><span class="n">corr</span><span class="p">,</span> <span class="n">river</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="c1"># overlaps at the junction result in losing points in the corridor polygon.</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">_isOverlappingCorridors</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">rivers</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Corridors can overlap&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">_isOverlappingCorridor</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">river</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">river</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">rivers</span><span class="p">)):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="n">corrs_area</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">unary_union</span><span class="p">(</span><span class="n">corrs</span><span class="p">)</span><span class="o">.</span><span class="n">area</span>
    <span class="n">summed_area</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">area</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corrs</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">summed_area</span> <span class="o">-</span> <span class="n">corrs_area</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.e-3</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">_isExpectedNumPoints</span><span class="p">(</span><span class="n">corr</span><span class="p">,</span> <span class="n">river</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if the points on the corridor are same as calculated theoretically&quot;&quot;&quot;</span>
    <span class="n">n_child</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">river</span><span class="o">.</span><span class="n">preOrder</span><span class="p">():</span>
        <span class="n">n_child</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># two outlet points</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">river</span><span class="o">.</span><span class="n">preOrder</span><span class="p">():</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">n_child</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">n_child</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_child</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">n_child</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">corr</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">n</span>


<div class="viewcode-block" id="create_rivers_meshes">
<a class="viewcode-back" href="../../mesh.html#watershed_workflow.river_mesh.create_rivers_meshes">[docs]</a>
<span class="k">def</span> <span class="nf">create_rivers_meshes</span><span class="p">(</span><span class="n">rivers</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">enforce_convexity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns list of elems and river corridor polygons for a given list of river trees</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    rivers: list(watershed_workflow.river_tree.River object)</span>
<span class="sd">        List of river tree along which river meshes are to be created</span>
<span class="sd">    widths: float or dict or callable or boolean </span>
<span class="sd">       Width of the quads, either a float or a dictionary providing a</span>
<span class="sd">       {StreamOrder : width} mapping.</span>
<span class="sd">       Or a function (callable) that computer width using node properties</span>
<span class="sd">       Or boolean, where True means, width for each reach is explicitely provided properties as &quot;width&quot;</span>
<span class="sd">    enforce_convexity: boolean </span>
<span class="sd">        If true, enforce convexity of the pentagons/hexagons at the</span>
<span class="sd">        junctions.</span>
<span class="sd">    ax : matplotlib Axes object, optional</span>
<span class="sd">        For debugging -- plots troublesome reaches as quad elements are</span>
<span class="sd">        generated to find tricky areas.</span>
<span class="sd">    label : bool, optional = True</span>
<span class="sd">        If true and ax is provided, animates the debugging plot with</span>
<span class="sd">        reach ID labels as the user hovers over the plot.  Requires a</span>
<span class="sd">        widget backend for matplotlib.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    elems: list(list)</span>
<span class="sd">        List of river elements, each element a list of indices into</span>
<span class="sd">        corr.coords.</span>
<span class="sd">    corrs: list(shapely.geometry.Polygon)</span>
<span class="sd">        List of river corridor polygons, one per river, storing the</span>
<span class="sd">        coordinates used in elems.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">elems</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">corrs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">gid_shift</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># set up debugging plot</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;  ... setting up debug figure&#39;</span><span class="p">)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39; magenta ^: first touch </span><span class="se">\n</span><span class="s1"> green o: leaf, final element &#39;</span>
                     <span class="s1">&#39;complete </span><span class="se">\n</span><span class="s1"> blue o: internal element complete &#39;</span><span class="p">)</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">river</span> <span class="ow">in</span> <span class="n">rivers</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">river</span><span class="o">.</span><span class="n">preOrder</span><span class="p">()]</span>
        <span class="n">reach_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">segment</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>
        <span class="n">reach_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>
        <span class="n">reach_colors</span> <span class="o">=</span> <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">enumerated_colors</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">shplys</span><span class="p">(</span><span class="n">reach_list</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">reach_colors</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">label</span><span class="p">:</span>
            <span class="c1"># the next block creates a hoverable plot where reaches are</span>
            <span class="c1"># annotated with their IDs.  This makes it easier for the user</span>
            <span class="c1"># to find the bad spot.</span>
            <span class="n">annot</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                                <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
                                <span class="n">textcoords</span><span class="o">=</span><span class="s2">&quot;offset points&quot;</span><span class="p">,</span>
                                <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">boxstyle</span><span class="o">=</span><span class="s2">&quot;round&quot;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">),</span>
                                <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s2">&quot;-&gt;&quot;</span><span class="p">))</span>
            <span class="n">annot</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">update_annot</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
                <span class="n">posx</span><span class="p">,</span> <span class="n">posy</span> <span class="o">=</span> <span class="n">reach_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">annot</span><span class="o">.</span><span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">posx</span><span class="p">,</span> <span class="n">posy</span><span class="p">)</span>
                <span class="n">text</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;ID: </span><span class="si">{</span><span class="n">reach_names</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="n">annot</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
                <span class="n">annot</span><span class="o">.</span><span class="n">get_bbox_patch</span><span class="p">()</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">reach_colors</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                <span class="n">annot</span><span class="o">.</span><span class="n">get_bbox_patch</span><span class="p">()</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="mf">0.8</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">hover</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
                <span class="n">vis</span> <span class="o">=</span> <span class="n">annot</span><span class="o">.</span><span class="n">get_visible</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">inaxes</span> <span class="o">==</span> <span class="n">ax</span><span class="p">:</span>
                    <span class="n">cont</span><span class="p">,</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">cont</span><span class="p">:</span>
                        <span class="n">update_annot</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="s1">&#39;ind&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">annot</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw_idle</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">vis</span><span class="p">:</span>
                            <span class="n">annot</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw_idle</span><span class="p">()</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s2">&quot;motion_notify_event&quot;</span><span class="p">,</span> <span class="n">hover</span><span class="p">)</span>

    <span class="c1"># now do the actual work</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">river</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rivers</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;River </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elems</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gid_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">elem</span><span class="p">))</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">elems</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">elems_river</span><span class="p">,</span> <span class="n">corr</span> <span class="o">=</span> <span class="n">create_river_mesh</span><span class="p">(</span><span class="n">river</span><span class="p">,</span>
                                              <span class="n">widths</span><span class="o">=</span><span class="n">widths</span><span class="p">,</span>
                                              <span class="n">enforce_convexity</span><span class="o">=</span><span class="n">enforce_convexity</span><span class="p">,</span>
                                              <span class="n">gid_shift</span><span class="o">=</span><span class="n">gid_shift</span><span class="p">,</span>
                                              <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

        <span class="n">elems</span> <span class="o">=</span> <span class="n">elems</span> <span class="o">+</span> <span class="n">elems_river</span>
        <span class="n">corrs</span> <span class="o">=</span> <span class="n">corrs</span> <span class="o">+</span> <span class="p">[</span><span class="n">corr</span><span class="p">,</span> <span class="p">]</span>

    <span class="k">if</span> <span class="n">_isOverlappingCorridors</span><span class="p">(</span><span class="n">corrs</span><span class="p">,</span> <span class="n">rivers</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Overlapping quad elements in neighboring rivers, try &#39;</span>
                           <span class="s1">&#39;reducing river width or check reach data&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">elems</span><span class="p">,</span> <span class="n">corrs</span></div>



<div class="viewcode-block" id="create_river_mesh">
<a class="viewcode-back" href="../../mesh.html#watershed_workflow.river_mesh.create_river_mesh">[docs]</a>
<span class="k">def</span> <span class="nf">create_river_mesh</span><span class="p">(</span><span class="n">river</span><span class="p">,</span>
                      <span class="n">widths</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                      <span class="n">enforce_convexity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">gid_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                      <span class="n">dilation_width</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                      <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns list of elems and river corridor polygons for a given river tree</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    river: watershed_workflow.river_tree.River object)</span>
<span class="sd">      River tree along which mesh is to be created</span>
<span class="sd">    widths: float or dict or callable or boolean </span>
<span class="sd">       Width of the quads, either a float or a dictionary providing a</span>
<span class="sd">       {StreamOrder : width} mapping.</span>
<span class="sd">       Or a function (callable) that computer width using node properties</span>
<span class="sd">       Or boolean, where True means, width for each reach is explicitely provided properties as &quot;width&quot;</span>
<span class="sd">    enforce_convexity: boolean </span>
<span class="sd">      If true, enforce convexity of the pentagons/hexagons at the</span>
<span class="sd">      junctions.</span>
<span class="sd">    gid_shift: int</span>
<span class="sd">      All the node-ids used in the element defination are shifted by</span>
<span class="sd">      this number to make it consistant with the global ids in the m2</span>
<span class="sd">      mesh, necessary in the case of multiple rivers</span>
<span class="sd">    dilation_width: float</span>
<span class="sd">      This is used for initial buffering of the river tree into the</span>
<span class="sd">      river corridor polygon.  For a typical watershed the 4 m default</span>
<span class="sd">      should work well; for smaller domains, setting smaller initial</span>
<span class="sd">      dilation_width might be desirable (much smaller than expected</span>
<span class="sd">      quad element length).</span>
<span class="sd">    ax : matplotlib Axes object, optional</span>
<span class="sd">      For debugging -- plots troublesome reaches as quad elements are</span>
<span class="sd">      generated to find tricky areas.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    elems: List(List)</span>
<span class="sd">        List of river elements, each element a list of indices into</span>
<span class="sd">        corr.coords.</span>
<span class="sd">    corr: shapely.geometry.Polygon</span>
<span class="sd">        The polygon of all elements, stores the coordinates.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># creating a polygon for river corridor by dilating the river tree</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">widths</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">dilation_width</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dilation_width</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">widths</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">widths</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">widths</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">dilation_width</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dilation_width</span><span class="p">,</span> <span class="n">widths</span><span class="p">)</span>

    <span class="n">corr</span> <span class="o">=</span> <span class="n">create_river_corridor</span><span class="p">(</span><span class="n">river</span><span class="p">,</span> <span class="n">dilation_width</span><span class="p">)</span>

    <span class="c1"># defining special elements in the mesh</span>
    <span class="n">elems</span> <span class="o">=</span> <span class="n">to_quads</span><span class="p">(</span><span class="n">river</span><span class="p">,</span> <span class="n">corr</span><span class="p">,</span> <span class="n">dilation_width</span><span class="p">,</span> <span class="n">gid_shift</span><span class="o">=</span><span class="n">gid_shift</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

    <span class="c1"># setting river_widths in the river corridor polygon</span>
    <span class="n">corr</span> <span class="o">=</span> <span class="n">set_width</span><span class="p">(</span><span class="n">river</span><span class="p">,</span> <span class="n">corr</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="n">widths</span><span class="p">,</span> <span class="n">dilation_width</span><span class="o">=</span><span class="n">dilation_width</span><span class="p">,</span> <span class="n">gid_shift</span><span class="o">=</span><span class="n">gid_shift</span><span class="p">)</span>

    <span class="c1"># treating non-convexity at junctions</span>
    <span class="k">if</span> <span class="n">enforce_convexity</span><span class="p">:</span>
        <span class="n">corr</span> <span class="o">=</span> <span class="n">convexity_enforcement</span><span class="p">(</span><span class="n">river</span><span class="p">,</span> <span class="n">corr</span><span class="p">,</span> <span class="n">gid_shift</span><span class="o">=</span><span class="n">gid_shift</span><span class="p">)</span>

    <span class="c1"># redraw the debug plot with updated elems</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">corr</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="n">e</span> <span class="o">-</span> <span class="n">gid_shift</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">])</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">elems</span><span class="p">]</span>
        <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">shplys</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>

    <span class="n">oc</span> <span class="o">=</span> <span class="n">_isOverlappingCorridor</span><span class="p">(</span><span class="n">corr</span><span class="p">,</span> <span class="n">river</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">oc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Overlapping quad elements away from a junction -- try &#39;</span>
                           <span class="s1">&#39;reducing river width or checking data to ensure no braided &#39;</span>
                           <span class="s1">&#39;or nearly braided systems&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">oc</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Overlapping quad elements at a junction -- try &#39;</span>
                           <span class="s1">&#39; increasing junction_angle_limit in densification, or check data.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">elems</span><span class="p">,</span> <span class="n">corr</span></div>



<div class="viewcode-block" id="create_river_corridor">
<a class="viewcode-back" href="../../mesh.html#watershed_workflow.river_mesh.create_river_corridor">[docs]</a>
<span class="k">def</span> <span class="nf">create_river_corridor</span><span class="p">(</span><span class="n">river</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a polygon representing the river corridor with a fixed</span>
<span class="sd">    dilation width.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    river : watershed_workflow.river_tree.River object</span>
<span class="sd">      River tree along which corridor polygon is to be created.</span>
<span class="sd">    width : float</span>
<span class="sd">      Width to dilate the river.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    shapely.geometry.Polygon</span>
<span class="sd">      Resulting polygon.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;... generating initial polygon through dilation (</span><span class="si">{</span><span class="n">width</span><span class="si">}</span><span class="s1"> m)&#39;</span><span class="p">)</span>
    <span class="c1"># first sort the river so that in a search we always take paddlers right...</span>
    <span class="c1"># check river consistency</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">river</span><span class="o">.</span><span class="n">is_continuous</span><span class="p">():</span>
        <span class="n">river</span><span class="o">.</span><span class="n">make_continuous</span><span class="p">()</span>
    <span class="n">sort_children_by_angle</span><span class="p">(</span><span class="n">river</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="c1"># make there are no three collinear points, else buffer will ignore those points</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;  -- treating collinearity&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">river</span><span class="o">.</span><span class="n">preOrder</span><span class="p">():</span>
        <span class="n">new_seg_coords</span> <span class="o">=</span> <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">treat_segment_collinearity</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">[:])</span>
        <span class="n">node</span><span class="o">.</span><span class="n">segment</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">LineString</span><span class="p">(</span><span class="n">new_seg_coords</span><span class="p">)</span>

    <span class="c1"># find smallest lengthscale as threshold to identify double and triple points</span>
    <span class="n">mins</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">river</span><span class="o">.</span><span class="n">depthFirst</span><span class="p">():</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">coords</span><span class="p">[:])</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">mins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dz</span><span class="p">))</span>

    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  -- river min seg length: </span><span class="si">{</span><span class="nb">min</span><span class="p">(</span><span class="n">mins</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Currently this same for the whole river, should we change it reachwise?</span>
    <span class="n">length_scale</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">2.1</span> <span class="o">*</span> <span class="n">delta</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">mins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">8</span><span class="o">*</span><span class="n">delta</span><span class="p">)</span>

    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  -- merging points closer than </span><span class="si">{</span><span class="n">length_scale</span><span class="si">}</span><span class="s2"> m along the river corridor&quot;</span><span class="p">)</span>

    <span class="c1"># buffer by the width</span>
    <span class="n">mls</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">MultiLineString</span><span class="p">([</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">river</span><span class="o">.</span><span class="n">depthFirst</span><span class="p">()])</span>
    <span class="n">corr</span> <span class="o">=</span> <span class="n">mls</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span>
                      <span class="n">cap_style</span><span class="o">=</span><span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">CAP_STYLE</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span>
                      <span class="n">join_style</span><span class="o">=</span><span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">JOIN_STYLE</span><span class="o">.</span><span class="n">mitre</span><span class="p">)</span>

    <span class="c1"># cycle the corridor points to start and end with the 1st point.</span>
    <span class="n">corr_p</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">corr</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">outlet_p</span> <span class="o">=</span> <span class="n">river</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">index_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">corr_p</span><span class="p">)),</span>
                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">corr_p</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">outlet_p</span><span class="p">))</span>
    <span class="n">plus_one</span> <span class="o">=</span> <span class="p">(</span><span class="n">index_min</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">corr_p</span><span class="p">)</span>
    <span class="n">minus_one</span> <span class="o">=</span> <span class="p">(</span><span class="n">index_min</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">corr_p</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">corr_p</span><span class="p">[</span><span class="n">plus_one</span><span class="p">],</span> <span class="n">outlet_p</span><span class="p">)</span>
            <span class="o">&lt;</span> <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">corr_p</span><span class="p">[</span><span class="n">minus_one</span><span class="p">],</span> <span class="n">outlet_p</span><span class="p">)):</span>
        <span class="n">corr2_p</span> <span class="o">=</span> <span class="n">corr_p</span><span class="p">[</span><span class="n">plus_one</span><span class="p">:]</span> <span class="o">+</span> <span class="n">corr_p</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">plus_one</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">corr2_p</span> <span class="o">=</span> <span class="n">corr_p</span><span class="p">[</span><span class="n">index_min</span><span class="p">:]</span> <span class="o">+</span> <span class="n">corr_p</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">index_min</span><span class="p">]</span>
    <span class="n">corr2</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">corr2_p</span><span class="p">)</span>

    <span class="c1"># remove endpoint-doubles that we want to be a single point and</span>
    <span class="c1"># weird artifact triples at junctions</span>
    <span class="n">corr3_p</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">corr2_p</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;considering </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">corr2_p</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># keep first and last always -- first two points make the outlet segment</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; always keeping&#39;</span><span class="p">)</span>
            <span class="n">corr3_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corr2_p</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">corr2_p</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">corr2_p</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">length_scale</span><span class="p">:</span>
                <span class="c1"># is this a triple point?</span>
                <span class="k">if</span> <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">corr2_p</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">corr2_p</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">length_scale</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39; triple point!&#39;</span><span class="p">)</span>
                    <span class="c1"># triple point, average neighbors and skip the next point</span>
                    <span class="n">corr3_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">midpoint</span><span class="p">(</span><span class="n">corr2_p</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                                                                     <span class="n">corr2_p</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># double point -- an end of a first order stream</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39; double point&#39;</span><span class="p">)</span>
                    <span class="n">corr3_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">midpoint</span><span class="p">(</span><span class="n">corr2_p</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">corr2_p</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># will the next point deal with this?</span>
                <span class="k">if</span> <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">corr2_p</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">corr2_p</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">length_scale</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39; not my problem&#39;</span><span class="p">)</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39; keeping&#39;</span><span class="p">)</span>
                    <span class="n">corr3_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corr2_p</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># create the polgyon</span>
    <span class="n">corr3</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">corr3_p</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># check if the points on the river corridor are same as calculated theoretically</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_isExpectedNumPoints</span><span class="p">(</span><span class="n">corr3</span><span class="p">,</span> <span class="n">river</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Broken dilation -- expected </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> coords, got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">corr3</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">[:])</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="s2">&quot; -- recommend running with ax argument to tessalate_river_aligned() to debug!&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">corr3</span></div>



<div class="viewcode-block" id="to_quads">
<a class="viewcode-back" href="../../mesh.html#watershed_workflow.river_mesh.to_quads">[docs]</a>
<span class="k">def</span> <span class="nf">to_quads</span><span class="p">(</span><span class="n">river</span><span class="p">,</span> <span class="n">corr</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">gid_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Iterate over the rivers, creating quads and pentagons forming the corridor.</span>

<span class="sd">    The global_id_adjustment is to keep track of node_id in elements</span>
<span class="sd">    w.r.t to global id in mesh mainly relevant for multiple river</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rivers : watershed_workflow.river_tree.River</span>
<span class="sd">      river tree </span>
<span class="sd">    corr : shapely.geometry.Polygon</span>
<span class="sd">      a river corridor polygon for the river</span>
<span class="sd">    width : float</span>
<span class="sd">      fixed width used for dilating the river</span>
<span class="sd">    gid_shift: int</span>
<span class="sd">      All the node-ids used in the element defination are shifted by</span>
<span class="sd">      this number to make it consistant with the global ids in the m2</span>
<span class="sd">      mesh, necessary in the case of multiple rivers.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    elems: list(list)</span>
<span class="sd">      List of river elements</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;... defining river-mesh topology (quad elements)&#39;</span><span class="p">)</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="n">coords</span> <span class="o">=</span> <span class="n">corr</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">artists</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of things added to ax here</span>
    <span class="kn">import</span> <span class="nn">time</span>

    <span class="k">def</span> <span class="nf">pause</span><span class="p">():</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>

    <span class="c1"># number the nodes in a dfs pattern, creating empty space for elements</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">river</span><span class="o">.</span><span class="n">preOrder</span><span class="p">()):</span>
        <span class="n">node</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">node</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">()</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">touched</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># iterate over the tree in an out-and-back-and-in-between</span>
    <span class="c1"># traversal, where every node appears num_children + 1 times,</span>
    <span class="c1"># before and after and between each child.</span>
    <span class="n">ic</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_touches</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">river</span><span class="o">.</span><span class="n">prePostInBetweenOrder</span><span class="p">():</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;touching </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s1"> (previously touched </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">touched</span><span class="si">}</span><span class="s1"> times with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span><span class="si">}</span><span class="s1"> children)&#39;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">touched</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;  first time around! </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">touched</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># not yet touched -- add the first coordinates</span>
            <span class="n">seg_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">[</span><span class="n">ic</span><span class="p">],</span> <span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">elements</span><span class="p">)):</span>
                <span class="n">node</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span>
                <span class="n">ic</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">node</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span>
                <span class="n">seg_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">ic</span><span class="p">])</span>

            <span class="n">node</span><span class="o">.</span><span class="n">touched</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">total_touches</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">seg_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">seg_coords</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ax</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">artists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">seg_coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">seg_coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;m^&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span>
                <span class="n">pause</span><span class="p">()</span>

        <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">touched</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># leaf node, last time</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; last time around a leaf! </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">touched</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># increment to avoid double-counting the point in the triangle on the ends</span>
            <span class="n">seg_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">[</span><span class="n">ic</span><span class="p">],</span> <span class="p">]</span>
            <span class="n">ic</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">node</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span>
            <span class="n">seg_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">ic</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="n">node</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span>
                <span class="n">ic</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">node</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span>
                <span class="n">seg_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">ic</span><span class="p">])</span>
            <span class="n">node</span><span class="o">.</span><span class="n">touched</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">total_touches</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">ax</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># plot it...</span>
                <span class="c1"># seg_coords = np.array(seg_coords)</span>
                <span class="c1"># artists.append(ax.plot(seg_coords[:, 0], seg_coords[:, 1], &#39;gv&#39;, markersize=5))</span>

                <span class="c1"># also plot the conn</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">elements</span><span class="p">):</span>
                    <span class="n">looped_conn</span> <span class="o">=</span> <span class="n">elem</span><span class="p">[:]</span>
                    <span class="n">looped_conn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">looped_conn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">looped_conn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
                    <span class="n">cc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">looped_conn</span><span class="p">])</span>
                    <span class="n">artists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">cc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;g-o&#39;</span><span class="p">))</span>
                <span class="n">pause</span><span class="p">()</span>

        <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">touched</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;  last time around! </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">touched</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">seg_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">[</span><span class="n">ic</span><span class="p">],</span> <span class="p">]</span>
            <span class="c1"># touched enough times that this is the last appearance</span>
            <span class="c1"># add the last coordinates</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">elements</span><span class="p">))):</span>
                <span class="n">node</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span>
                <span class="n">ic</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">node</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span>
                <span class="n">seg_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">ic</span><span class="p">])</span>
            <span class="n">node</span><span class="o">.</span><span class="n">touched</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">total_touches</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">ax</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1">#plot it...</span>
                <span class="n">seg_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">seg_coords</span><span class="p">)</span>
                <span class="n">artists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">seg_coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">seg_coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;b^&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span>

            <span class="c1"># also plot the conn</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">elements</span><span class="p">):</span>
                <span class="n">looped_conn</span> <span class="o">=</span> <span class="n">elem</span><span class="p">[:]</span>
                <span class="n">looped_conn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">looped_conn</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">touched</span> <span class="o">+</span> <span class="mi">3</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">looped_conn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
                <span class="n">cc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">looped_conn</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">ax</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">artists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">cc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;b-o&#39;</span><span class="p">))</span>

                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cc</span><span class="p">:</span>
                    <span class="c1"># What is this actually checking?  Need a comment here -- this is confusing code. --ETC</span>
                    <span class="c1">#</span>
                    <span class="c1"># note, the more acute an angle, the bigger this distance can get...</span>
                    <span class="c1"># so it is a bit hard to pin this multiple down -- using 25 seems ok?</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">node</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="mi">25</span><span class="o">*</span><span class="n">delta</span><span class="p">)</span> <span class="ow">or</span> \
                           <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">node</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)],</span> <span class="mi">25</span><span class="o">*</span><span class="n">delta</span><span class="p">)):</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span>
                                      <span class="n">node</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)])</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                        <span class="k">assert</span><span class="p">(</span><span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">node</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="mi">25</span><span class="o">*</span><span class="n">delta</span><span class="p">)</span> <span class="ow">or</span> \
                        <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">node</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)],</span> <span class="mi">25</span><span class="o">*</span><span class="n">delta</span><span class="p">))</span>

            <span class="n">pause</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># adding the junction point</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;  middle time around! </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">touched</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">touched</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>
            <span class="c1"># touched in between children</span>
            <span class="c1"># therefore this is at least a pentagon</span>
            <span class="c1"># add the middle node on the last element</span>
            <span class="n">node</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span>
            <span class="n">node</span><span class="o">.</span><span class="n">touched</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">ax</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">artists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="n">ic</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="p">],</span> <span class="p">[</span><span class="n">coords</span><span class="p">[</span><span class="n">ic</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;^&#39;</span><span class="p">))</span>
                <span class="n">pause</span><span class="p">()</span>

    <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">ic</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">river</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">total_touches</span><span class="p">)</span>

    <span class="c1"># this nodeid-shift is needed in case of multiple rivers, to make</span>
    <span class="c1"># this id consistent with global node ids in a m2 mesh</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">river</span><span class="o">.</span><span class="n">preOrder</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">elems</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">elements</span><span class="p">):</span>
            <span class="n">elems_new</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_id</span> <span class="o">+</span> <span class="n">gid_shift</span> <span class="k">for</span> <span class="n">node_id</span> <span class="ow">in</span> <span class="n">elems</span><span class="p">]</span>
            <span class="n">node</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">elems_new</span>

    <span class="n">elems</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">river</span><span class="o">.</span><span class="n">preOrder</span><span class="p">()</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">elements</span><span class="p">]</span>

    <span class="c1"># once we have reached here, the debug plot is not so needed anymore,</span>
    <span class="c1"># and leaving all our dots makes things cluttered.</span>
    <span class="k">for</span> <span class="n">artist</span> <span class="ow">in</span> <span class="n">artists</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">artist</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">artist</span><span class="p">:</span>
                <span class="n">it</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">artist</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">elems</span></div>



<div class="viewcode-block" id="set_width">
<a class="viewcode-back" href="../../mesh.html#watershed_workflow.river_mesh.set_width">[docs]</a>
<span class="k">def</span> <span class="nf">set_width</span><span class="p">(</span><span class="n">river</span><span class="p">,</span> <span class="n">corr</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">dilation_width</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">gid_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adjust the river-corridor polygon width by order.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    river: watershed_workflow.river_tree.River</span>
<span class="sd">      river tree along which mesh is to be created</span>
<span class="sd">    corr : shapely.geometry.Polygon</span>
<span class="sd">      a river corridor polygon for the river    </span>
<span class="sd">    widths: float or dict or callable or boolean </span>
<span class="sd">       Width of the quads, either a float or a dictionary providing a</span>
<span class="sd">       {StreamOrder : width} mapping.</span>
<span class="sd">       Or a function (callable) that computer width using node properties</span>
<span class="sd">       Or boolean, where True means, width for each reach is explicitely provided properties as &quot;width&quot;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    shapely.geometry.Polygon</span>
<span class="sd">      river corridor polygon with adjusted width</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;... setting width of quad elements&quot;</span><span class="p">)</span>
    <span class="n">corr_coords</span> <span class="o">=</span> <span class="n">corr</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">stream_order</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
            <span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;StreamOrder&#39;</span><span class="p">,</span> <span class="s1">&#39;streamorder&#39;</span><span class="p">,</span> <span class="s1">&#39;streamorde&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">river</span><span class="o">.</span><span class="n">properties</span><span class="p">),</span>
            <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stream_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s1">&#39;set_width_by_order requested widths by stream order, but cannot guess stream order property name&#39;</span>
            <span class="p">)</span>

    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">river</span><span class="o">.</span><span class="n">preOrder</span><span class="p">()):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="n">stream_order</span><span class="p">]</span>
            <span class="n">target_width</span> <span class="o">=</span> <span class="n">width_by_order</span><span class="p">(</span><span class="n">widths</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">widths</span><span class="p">):</span>
            <span class="c1">## DA_sqm = node.properties[&#39;TotalDrainageAreaSqKm&#39;] * 1e6</span>
            <span class="c1"># genralized, the above calclations should be done in the function itself</span>
            <span class="c1"># widths here is a function of node, where</span>
            <span class="c1"># widths wil be calculated based on some properties in the node</span>
            <span class="n">target_width</span> <span class="o">=</span> <span class="n">widths</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">widths</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">widths</span><span class="p">:</span>
                <span class="n">target_width</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;not a valid option to provide width&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target_width</span> <span class="o">=</span> <span class="n">widths</span>

        <span class="c1"># loop over elems, treating the upstream edge</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">elements</span><span class="p">):</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="p">[</span><span class="nb">id</span> <span class="o">-</span> <span class="n">gid_shift</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># no upstream edge</span>

            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]][:</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># points of the upstream edge of the quad</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]][:</span><span class="mi">2</span><span class="p">])</span>
                <span class="p">[</span><span class="n">p1_</span><span class="p">,</span> <span class="n">p2_</span><span class="p">]</span> <span class="o">=</span> <span class="n">move_to_target_separation</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span>
                                                       <span class="n">p2</span><span class="p">,</span>
                                                       <span class="n">target_width</span><span class="p">,</span>
                                                       <span class="n">dilation_width</span><span class="o">=</span><span class="n">dilation_width</span><span class="p">)</span>
                <span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p1_</span><span class="p">)</span>
                <span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p2_</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]][:</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># neck of the pent</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">3</span><span class="p">]][:</span><span class="mi">2</span><span class="p">])</span>
                <span class="p">[</span><span class="n">p1_</span><span class="p">,</span> <span class="n">p2_</span><span class="p">]</span> <span class="o">=</span> <span class="n">move_to_target_separation</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span>
                                                       <span class="n">p2</span><span class="p">,</span>
                                                       <span class="n">target_width</span><span class="p">,</span>
                                                       <span class="n">dilation_width</span><span class="o">=</span><span class="n">dilation_width</span><span class="p">)</span>
                <span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p1_</span><span class="p">)</span>
                <span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p2_</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]][:</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># neck of the hex</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">3</span><span class="p">]][:</span><span class="mi">2</span><span class="p">])</span>
                <span class="p">[</span><span class="n">p1_</span><span class="p">,</span> <span class="n">p2_</span><span class="p">]</span> <span class="o">=</span> <span class="n">move_to_target_separation</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span>
                                                       <span class="n">p2</span><span class="p">,</span>
                                                       <span class="n">target_width</span><span class="p">,</span>
                                                       <span class="n">dilation_width</span><span class="o">=</span><span class="n">dilation_width</span><span class="p">)</span>
                <span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p1_</span><span class="p">)</span>
                <span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p2_</span><span class="p">)</span>

                <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]][:</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># in one</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">4</span><span class="p">]][:</span><span class="mi">2</span><span class="p">])</span>
                <span class="p">[</span><span class="n">p1_</span><span class="p">,</span> <span class="n">p2_</span><span class="p">]</span> <span class="o">=</span> <span class="n">move_to_target_separation</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span>
                                                       <span class="n">p2</span><span class="p">,</span>
                                                       <span class="n">target_width</span><span class="p">,</span>
                                                       <span class="n">dilation_width</span><span class="o">=</span><span class="n">dilation_width</span><span class="p">)</span>
                <span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p1_</span><span class="p">)</span>
                <span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p2_</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]][:</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># neck of the sept</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">4</span><span class="p">]][:</span><span class="mi">2</span><span class="p">])</span>
                <span class="p">[</span><span class="n">p1_</span><span class="p">,</span> <span class="n">p2_</span><span class="p">]</span> <span class="o">=</span> <span class="n">move_to_target_separation</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span>
                                                       <span class="n">p2</span><span class="p">,</span>
                                                       <span class="n">target_width</span><span class="p">,</span>
                                                       <span class="n">dilation_width</span><span class="o">=</span><span class="n">dilation_width</span><span class="p">)</span>
                <span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p1_</span><span class="p">)</span>
                <span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p2_</span><span class="p">)</span>

                <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]][:</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># in one</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">5</span><span class="p">]][:</span><span class="mi">2</span><span class="p">])</span>
                <span class="p">[</span><span class="n">p1_</span><span class="p">,</span> <span class="n">p2_</span><span class="p">]</span> <span class="o">=</span> <span class="n">move_to_target_separation</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span>
                                                       <span class="n">p2</span><span class="p">,</span>
                                                       <span class="n">target_width</span><span class="p">,</span>
                                                       <span class="n">dilation_width</span><span class="o">=</span><span class="n">dilation_width</span><span class="p">)</span>
                <span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p1_</span><span class="p">)</span>
                <span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">5</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p2_</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Case with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span><span class="si">}</span><span class="s2"> nodes is not yet treated... good luck!&quot;</span><span class="p">)</span>

            <span class="c1"># treat the most downstream edge, which is left out so far</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># points of the upstream edge of the quad/pent</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]][:</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][:</span><span class="mi">2</span><span class="p">])</span>
                <span class="p">[</span><span class="n">p1_</span><span class="p">,</span> <span class="n">p2_</span><span class="p">]</span> <span class="o">=</span> <span class="n">move_to_target_separation</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span>
                                                       <span class="n">p2</span><span class="p">,</span>
                                                       <span class="n">target_width</span><span class="p">,</span>
                                                       <span class="n">dilation_width</span><span class="o">=</span><span class="n">dilation_width</span><span class="p">)</span>
                <span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p1_</span><span class="p">)</span>
                <span class="n">corr_coords</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p2_</span><span class="p">)</span>

    <span class="n">corr_coords_new</span> <span class="o">=</span> <span class="n">corr_coords</span> <span class="o">+</span> <span class="p">[</span><span class="n">corr_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">corr_coords_new</span><span class="p">)</span></div>



<div class="viewcode-block" id="move_to_target_separation">
<a class="viewcode-back" href="../../mesh.html#watershed_workflow.river_mesh.move_to_target_separation">[docs]</a>
<span class="k">def</span> <span class="nf">move_to_target_separation</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">dilation_width</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the points after moving them to a target separation from each other&quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">math</span>
    <span class="n">d_vec</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">p2</span>  <span class="c1"># separation vector</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d_vec</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d_vec</span><span class="p">))</span>  <span class="c1"># distance</span>

    <span class="c1"># scales for angled joints (not exactly calculated but should be good enough)</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">target</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">d</span> <span class="o">/</span> <span class="n">dilation_width</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">d</span>
    <span class="n">p1_</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">delta</span> <span class="o">*</span> <span class="p">(</span><span class="n">d_vec</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span>
    <span class="n">p2_</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">delta</span> <span class="o">*</span> <span class="p">(</span><span class="n">d_vec</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span>
    <span class="n">d_</span> <span class="o">=</span> <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">p1_</span><span class="p">,</span> <span class="n">p2_</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">d_</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">rel_tol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">p1_</span><span class="p">,</span> <span class="n">p2_</span><span class="p">]</span></div>



<div class="viewcode-block" id="width_by_order">
<a class="viewcode-back" href="../../mesh.html#watershed_workflow.river_mesh.width_by_order">[docs]</a>
<span class="k">def</span> <span class="nf">width_by_order</span><span class="p">(</span><span class="n">width_dict</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the reach width based using the {order:width dictionary}&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">order</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">width_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">width_dict</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">width_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())]</span>
    <span class="k">elif</span> <span class="n">order</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">width_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">width_dict</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">width_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">width_dict</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">width</span></div>



<div class="viewcode-block" id="convexity_enforcement">
<a class="viewcode-back" href="../../mesh.html#watershed_workflow.river_mesh.convexity_enforcement">[docs]</a>
<span class="k">def</span> <span class="nf">convexity_enforcement</span><span class="p">(</span><span class="n">river</span><span class="p">,</span> <span class="n">corr</span><span class="p">,</span> <span class="n">gid_shift</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ensure convexity of each river-corridor element.</span>

<span class="sd">    Moves nodes onto the convex hull of the element if needed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    river: watershed_workflow.river_tree.River</span>
<span class="sd">      River tree along which mesh is to be created</span>
<span class="sd">    corr : shapely.geometry.Polygon</span>
<span class="sd">      The river corridor polygon</span>
<span class="sd">  </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    shapely.geometry.Polygon</span>
<span class="sd">      The new polygon with all convex elements.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;... enforcing convexity&#39;</span><span class="p">)</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">corr</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">river</span><span class="o">.</span><span class="n">preOrder</span><span class="p">()):</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="p">[</span><span class="nb">id</span> <span class="o">-</span> <span class="n">gid_shift</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span>
                    <span class="n">elem</span><span class="p">)</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>  <span class="c1"># checking and treating this pentagon/hexagon</span>
                <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">]</span>  <span class="c1"># element points</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">is_convex</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
                    <span class="n">points</span> <span class="o">=</span> <span class="n">make_convex_using_hull</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">is_convex</span><span class="p">(</span><span class="n">points</span><span class="p">)):</span>
                    <span class="c1"># go back to original set of points as snapping on</span>
                    <span class="c1"># hull might have incorrectly oriented points</span>
                    <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">]</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;  could not make these: </span><span class="si">{</span><span class="n">points</span><span class="si">}</span><span class="s2"> convex using convex hull, trying nudging....&quot;</span>
                    <span class="p">)</span>
                    <span class="n">points</span> <span class="o">=</span> <span class="n">make_convex_by_nudge</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

                <span class="k">assert</span> <span class="p">((</span><span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">is_convex</span><span class="p">(</span><span class="n">points</span><span class="p">)))</span>
                <span class="k">for</span> <span class="nb">id</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
                    <span class="n">coords</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">point</span>

    <span class="n">corr_coords_new</span> <span class="o">=</span> <span class="n">coords</span> <span class="o">+</span> <span class="p">[</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">corr_coords_new</span><span class="p">)</span></div>



<div class="viewcode-block" id="make_convex_using_hull">
<a class="viewcode-back" href="../../mesh.html#watershed_workflow.river_mesh.make_convex_using_hull">[docs]</a>
<span class="k">def</span> <span class="nf">make_convex_using_hull</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Snaps non-convex points to the corresonding edge on the convex hull for the non-convex element&quot;&quot;&quot;</span>
    <span class="c1"># find points that do not lie on the hull</span>
    <span class="n">hull</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="n">hull_indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">hull</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
    <span class="n">non_hull_points_inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hull_indices</span><span class="p">]</span>

    <span class="c1"># for each non-hull point, get the linestring connecting it&#39;s preceding point and suceeding point</span>
    <span class="n">hull_edges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">non_hull_points_inds</span><span class="p">:</span>
        <span class="n">prev_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span>
        <span class="n">next_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span>

        <span class="n">edge</span> <span class="o">=</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">prev_index</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="n">next_index</span><span class="p">])</span>
        <span class="n">hull_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">LineString</span><span class="p">(</span><span class="n">edge</span><span class="p">))</span>

    <span class="c1"># for each pair of non-hull point find nearest point on the corresponding hull_edge</span>
    <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">hull_edge</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">non_hull_points_inds</span><span class="p">,</span> <span class="n">hull_edges</span><span class="p">):</span>
        <span class="n">nearest_point_on_hull_edge</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">nearest_points</span><span class="p">(</span>
            <span class="n">hull_edge</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">ind</span><span class="p">]))</span>
        <span class="n">points</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">nearest_point_on_hull_edge</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">points</span></div>



<div class="viewcode-block" id="make_convex_by_nudge">
<a class="viewcode-back" href="../../mesh.html#watershed_workflow.river_mesh.make_convex_by_nudge">[docs]</a>
<span class="k">def</span> <span class="nf">make_convex_by_nudge</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Nudges the neck-points of the junction until the element is convex.</span>

<span class="sd">    Used if efficient convexity does not work</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">is_convex</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
            <span class="n">p1</span><span class="p">,</span> <span class="n">p3</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">3</span><span class="p">])]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">p3</span>
            <span class="n">p1_</span> <span class="o">=</span> <span class="n">p3</span> <span class="o">+</span> <span class="mf">1.01</span><span class="o">*</span><span class="n">d</span>
            <span class="n">p3_</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">-</span> <span class="mf">1.01</span><span class="o">*</span><span class="n">d</span>
            <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p1_</span><span class="p">)</span>
            <span class="n">points</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p3_</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;... element was adjusted </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> times&quot;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">is_convex</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
            <span class="n">p1</span><span class="p">,</span> <span class="n">p4</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">4</span><span class="p">])]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">p4</span>
            <span class="n">p1_</span> <span class="o">=</span> <span class="n">p4</span> <span class="o">+</span> <span class="mf">1.01</span><span class="o">*</span><span class="n">d</span>
            <span class="n">p4_</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">-</span> <span class="mf">1.01</span><span class="o">*</span><span class="n">d</span>
            <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p1_</span><span class="p">)</span>
            <span class="n">points</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p4_</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;... element was adjusted </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> times&quot;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">is_convex</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
            <span class="n">p1</span><span class="p">,</span> <span class="n">p5</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">5</span><span class="p">])]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">p5</span>
            <span class="n">p1_</span> <span class="o">=</span> <span class="n">p5</span> <span class="o">+</span> <span class="mf">1.01</span><span class="o">*</span><span class="n">d</span>
            <span class="n">p5_</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">-</span> <span class="mf">1.01</span><span class="o">*</span><span class="n">d</span>
            <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p1_</span><span class="p">)</span>
            <span class="n">points</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p5_</span><span class="p">)</span>

            <span class="n">p2</span><span class="p">,</span> <span class="n">p4</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">4</span><span class="p">])]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">-</span> <span class="n">p4</span>
            <span class="n">p2_</span> <span class="o">=</span> <span class="n">p4</span> <span class="o">+</span> <span class="mf">1.01</span><span class="o">*</span><span class="n">d</span>
            <span class="n">p4_</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">-</span> <span class="mf">1.01</span><span class="o">*</span><span class="n">d</span>
            <span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p2_</span><span class="p">)</span>
            <span class="n">points</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p4_</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;... element was adjusted </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> times&quot;</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Case with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="si">}</span><span class="s2"> nodes is not yet treated... good luck!&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">is_convex</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">points</span></div>



<span class="c1">## Supporting functions for river meshing: accomodate river corridor with internal huc boundaries</span>
<span class="c1">## generally rc = river corridor; rt = river tree</span>


<div class="viewcode-block" id="hucsegs_at_intersection">
<a class="viewcode-back" href="../../mesh.html#watershed_workflow.river_mesh.hucsegs_at_intersection">[docs]</a>
<span class="k">def</span> <span class="nf">hucsegs_at_intersection</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">hucs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;For a given intersection point, return a list of indices for huc.segments touching this point&quot;&quot;&quot;</span>
    <span class="n">intersection_segs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hucs</span><span class="o">.</span><span class="n">segments</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">seg</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
            <span class="n">intersection_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">intersection_segs</span></div>



<span class="k">def</span> <span class="nf">node_at_intersection</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">river</span><span class="p">):</span>
    <span class="c1"># for a given intersection point, find all the huc-segments (indices)</span>
    <span class="n">intersection_node</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">len_scale</span> <span class="o">=</span> <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">river</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">river</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">river</span><span class="o">.</span><span class="n">preOrder</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">point</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">len_scale</span><span class="p">)</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">segment</span><span class="p">):</span>
            <span class="n">intersection_node</span> <span class="o">=</span> <span class="n">node</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">intersection_node</span>


<div class="viewcode-block" id="angle_rivers_segs">
<a class="viewcode-back" href="../../mesh.html#watershed_workflow.river_mesh.angle_rivers_segs">[docs]</a>
<span class="k">def</span> <span class="nf">angle_rivers_segs</span><span class="p">(</span><span class="n">ref_seg</span><span class="p">,</span> <span class="n">seg</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the angle of incoming-river-segment or huc-segment w.r.t outgoing river.</span>

<span class="sd">    The angle is measured clockwise; this is useful to sort</span>
<span class="sd">    orientation wise and add river corridor points at junction</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ref_seg_tan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_seg</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_seg</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span> <span class="ow">is</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">LineString</span><span class="p">:</span>
        <span class="n">intersection_point</span> <span class="o">=</span> <span class="n">ref_seg</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">intersection_point</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Point</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;  HUC segment and river reach has two intersection points </span><span class="si">{</span><span class="n">intersection_point</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">seg_orientation_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">([</span>
            <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">seg_end</span><span class="p">,</span> <span class="n">intersection_point</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">seg_end</span> <span class="ow">in</span> <span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="p">])</span>
        <span class="k">if</span> <span class="n">seg_orientation_flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">seg_tan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">seg_orientation_flag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">seg_tan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="o">-</span><span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">ref_seg_tan</span><span class="p">,</span> <span class="n">seg_tan</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span> <span class="ow">is</span> <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">river_tree</span><span class="o">.</span><span class="n">River</span><span class="p">:</span>
        <span class="n">seg_tan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="o">-</span><span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">ref_seg_tan</span><span class="p">,</span> <span class="n">seg_tan</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">angle</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">angle</span> <span class="o">+</span> <span class="mi">360</span>
    <span class="k">return</span> <span class="n">angle</span></div>



<div class="viewcode-block" id="rc_points_for_rt_point">
<a class="viewcode-back" href="../../mesh.html#watershed_workflow.river_mesh.rc_points_for_rt_point">[docs]</a>
<span class="k">def</span> <span class="nf">rc_points_for_rt_point</span><span class="p">(</span><span class="n">rt_point</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">river_corr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the points (list of indices of coords) on the river-corridor-polygon for a given junction point on river tree.&quot;&quot;&quot;</span>
    <span class="c1">#assert (node.segment.intersects(rt_point))</span>
    <span class="n">rt_point_ind</span> <span class="o">=</span> <span class="n">_indexPointInSeg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">segment</span><span class="p">,</span> <span class="n">rt_point</span><span class="p">)</span>

    <span class="c1"># this give id of stream mesh element which has this rt point  at upstream end</span>
    <span class="n">elem_ind</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">rt_point_ind</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">elem</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">elem_ind</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="c1"># return two points</span>
        <span class="n">rc_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">river_corr</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]]]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="c1"># return three points at junction</span>
        <span class="n">rc_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">river_corr</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">elem</span><span class="p">[</span><span class="mi">3</span><span class="p">]]]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
        <span class="c1"># return three points at junction</span>
        <span class="n">rc_points</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">river_corr</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">elem</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">elem</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span>
        <span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Too many points in elem?&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rc_points</span></div>



<div class="viewcode-block" id="adjust_seg_for_rc">
<a class="viewcode-back" href="../../mesh.html#watershed_workflow.river_mesh.adjust_seg_for_rc">[docs]</a>
<span class="k">def</span> <span class="nf">adjust_seg_for_rc</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">river_corr</span><span class="p">,</span> <span class="n">new_seg_point</span><span class="p">,</span> <span class="n">integrate_rc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the modified segment accomodating river-corridor-polygon (exclude river corridor or integrate with it).&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">integrate_rc</span><span class="p">:</span>
        <span class="n">len_scale</span> <span class="o">=</span> <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">river_corr</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                      <span class="n">river_corr</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">seg</span> <span class="o">=</span> <span class="n">seg</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">river_corr</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">0.1</span>
                                               <span class="o">*</span> <span class="n">len_scale</span><span class="p">))</span>  <span class="c1"># removing seg points inside the RC</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span>
                <span class="n">seg</span>
        <span class="p">)</span> <span class="ow">is</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">MultiLineString</span><span class="p">:</span>  <span class="c1"># sometimes small portion of the segment can end up on the other side of the rc</span>
            <span class="n">seg</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="n">seg_</span><span class="o">.</span><span class="n">length</span> <span class="k">for</span> <span class="n">seg_</span> <span class="ow">in</span> <span class="n">seg</span><span class="p">])]</span>
        <span class="n">seg_orientation_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">([</span>
            <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">seg_end</span><span class="p">,</span> <span class="n">new_seg_point</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">seg_end</span> <span class="ow">in</span> <span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="p">])</span>
        <span class="k">if</span> <span class="n">seg_orientation_flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">seg</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">LineString</span><span class="p">([</span><span class="n">new_seg_point</span><span class="p">,</span> <span class="p">]</span> <span class="o">+</span> <span class="n">seg</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">elif</span> <span class="n">seg_orientation_flag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">seg</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">LineString</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">coords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">new_seg_point</span><span class="p">,</span> <span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">seg_orientation_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">([</span>
            <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">seg_end</span><span class="p">,</span> <span class="n">new_seg_point</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">seg_end</span> <span class="ow">in</span> <span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="p">])</span>
        <span class="k">if</span> <span class="n">seg_orientation_flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">seg</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">LineString</span><span class="p">([</span><span class="n">new_seg_point</span><span class="p">,</span> <span class="p">]</span> <span class="o">+</span> <span class="n">seg</span><span class="o">.</span><span class="n">coords</span><span class="p">[:])</span>
        <span class="k">elif</span> <span class="n">seg_orientation_flag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">seg</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">LineString</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">coords</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span><span class="n">new_seg_point</span><span class="p">,</span> <span class="p">])</span>
    <span class="k">return</span> <span class="n">seg</span></div>



<div class="viewcode-block" id="adjust_hucs_for_river_corridors">
<a class="viewcode-back" href="../../mesh.html#watershed_workflow.river_mesh.adjust_hucs_for_river_corridors">[docs]</a>
<span class="k">def</span> <span class="nf">adjust_hucs_for_river_corridors</span><span class="p">(</span><span class="n">hucs</span><span class="p">,</span> <span class="n">rivers</span><span class="p">,</span> <span class="n">river_corrs</span><span class="p">,</span> <span class="n">integrate_rc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adjusts hucs to accomodate river corridor polygons.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hucs : SplitHUCs</span>
<span class="sd">        A split-form HUC object from, e.g., get_split_form_hucs(), will be modified in place.</span>
<span class="sd">    rivers : list(watershed_workflow.river_tree.River)</span>
<span class="sd">        A list of river tree object</span>
<span class="sd">    river_corrs : list(shapely.geometry.Polygons)</span>
<span class="sd">        A list of river corridor polygons for each river</span>
<span class="sd">    integrate_rc: bool, optional</span>
<span class="sd">        if false, will leave gap in the huc whereever rc crosses huc except at the overall outlet; </span>
<span class="sd">        hence hucs.polygons() will break, this mode is to be used during triangulation to creates NodesEdges object </span>
<span class="sd">        with a rc as a whole </span>
<span class="sd">        if true, will extend the hucs-segments alogn the edge of quads </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gid_shift</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">river</span><span class="p">,</span> <span class="n">river_corr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rivers</span><span class="p">,</span> <span class="n">river_corrs</span><span class="p">):</span>
        <span class="n">adjust_hucs_for_river_corridor</span><span class="p">(</span><span class="n">hucs</span><span class="p">,</span>
                                       <span class="n">river</span><span class="p">,</span>
                                       <span class="n">river_corr</span><span class="p">,</span>
                                       <span class="n">gid_shift</span><span class="o">=</span><span class="n">gid_shift</span><span class="p">,</span>
                                       <span class="n">integrate_rc</span><span class="o">=</span><span class="n">integrate_rc</span><span class="p">,</span>
                                       <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">gid_shift</span> <span class="o">=</span> <span class="n">gid_shift</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">river_corr</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span></div>



<div class="viewcode-block" id="adjust_hucs_for_river_corridor">
<a class="viewcode-back" href="../../mesh.html#watershed_workflow.river_mesh.adjust_hucs_for_river_corridor">[docs]</a>
<span class="k">def</span> <span class="nf">adjust_hucs_for_river_corridor</span><span class="p">(</span><span class="n">hucs</span><span class="p">,</span>
                                   <span class="n">river</span><span class="p">,</span>
                                   <span class="n">river_corr</span><span class="p">,</span>
                                   <span class="n">gid_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                   <span class="n">integrate_rc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adjusts hucs to accomodate river corridor polygon.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hucs : SplitHUCs</span>
<span class="sd">        A split-form HUC object from, e.g., get_split_form_hucs()</span>
<span class="sd">    river : watershed_workflow.river_tree.River object</span>
<span class="sd">        river tree </span>
<span class="sd">    river_corr : shapely.geometry.Polygons</span>
<span class="sd">        A river corridor polygon for given river</span>
<span class="sd">    integrate_rc: bool, optional</span>
<span class="sd">        If false, this will leave gap in the huc whereever rc crosses</span>
<span class="sd">        huc except at the overall outlet; hence hucs.polygons() will</span>
<span class="sd">        break, this mode is to be used during triangulation to creates</span>
<span class="sd">        NodesEdges object with a rc as a whole.  If true, will extend</span>
<span class="sd">        the hucs-segments alogn the edge of quads.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;  adjusting HUC boundary to include the river outlet segments&quot;</span><span class="p">)</span>
    <span class="c1"># rt = river tree; rc = river corridor</span>
    <span class="n">river_mls</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">MultiLineString</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">river</span><span class="p">))</span>  <span class="c1"># for checking intersection</span>

    <span class="n">huc_segs_adjusted</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># keep track of already modified hucs</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hucs</span><span class="o">.</span><span class="n">segments</span><span class="p">):</span>
        <span class="n">is_unadjusted_outlet_point</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># check if this huc is part of already processed junction</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">huc_segs_adjusted</span> <span class="ow">and</span> <span class="n">seg</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">river_mls</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;  ... found an intersection of river and huc seg&quot;</span><span class="p">)</span>
            <span class="n">intersection_point</span> <span class="o">=</span> <span class="n">seg</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">river_mls</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">intersection_point</span><span class="p">)</span> <span class="ow">is</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Point</span><span class="p">:</span>
                <span class="n">parent_node</span> <span class="o">=</span> <span class="n">node_at_intersection</span><span class="p">(</span><span class="n">intersection_point</span><span class="p">,</span> <span class="n">river</span><span class="p">)</span>
                <span class="c1"># making sure it is not a leaf node, though this check</span>
                <span class="c1"># fails if there is only one reach in the domain. So</span>
                <span class="c1"># this may fail for a single reach that begins and</span>
                <span class="c1"># ends on the boundary. -- fix me!</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">river</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent_node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">is_unadjusted_outlet_point</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">intersection_point</span><span class="p">)</span> <span class="ow">is</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">MultiPoint</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">intersection_point</span><span class="p">:</span>
                    <span class="n">parent_node</span> <span class="o">=</span> <span class="n">node_at_intersection</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">river</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent_node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">is_unadjusted_outlet_point</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">intersection_point</span> <span class="o">=</span> <span class="n">point</span>

        <span class="k">if</span> <span class="n">is_unadjusted_outlet_point</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;  ... it is an unadjusted outlet!&quot;</span><span class="p">)</span>

            <span class="c1"># hopefully no LineStrings or MultiPoints</span>
            <span class="c1"># assert(type(intersection_point) is shapely.geometry.Point)</span>

            <span class="c1"># find all the huc-segments at this junction</span>
            <span class="n">intersection_segs</span> <span class="o">=</span> <span class="n">hucsegs_at_intersection</span><span class="p">(</span><span class="n">intersection_point</span><span class="p">,</span> <span class="n">hucs</span><span class="p">)</span>
            <span class="n">huc_segs_adjusted</span> <span class="o">=</span> <span class="n">huc_segs_adjusted</span> <span class="o">+</span> <span class="n">intersection_segs</span>

            <span class="c1"># mark them as modified (in the following steps)</span>

            <span class="c1"># find the downstream node (outgoing river reach) at this junction</span>
            <span class="n">parent_node</span> <span class="o">=</span> <span class="n">node_at_intersection</span><span class="p">(</span><span class="n">intersection_point</span><span class="p">,</span> <span class="n">river</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">parent_node</span><span class="o">.</span><span class="n">parent</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># check if it is the outlet node for this river</span>
                <span class="n">outlet_junction</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">outlet_junction</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ... is there a parent to this? </span><span class="si">{</span><span class="n">parent_node</span><span class="o">.</span><span class="n">parent</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># find the index of the intersection point (at this</span>
            <span class="c1"># junction) on the rt-node-segment (needed to find rc</span>
            <span class="c1"># points)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ind_intersection_point</span> <span class="o">=</span> <span class="n">_indexPointInSeg</span><span class="p">(</span><span class="n">parent_node</span><span class="o">.</span><span class="n">segment</span><span class="p">,</span> <span class="n">intersection_point</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">IntersectionError</span><span class="p">()</span>
                <span class="n">err</span><span class="o">.</span><span class="n">point</span> <span class="o">=</span> <span class="n">intersection_point</span>
                <span class="n">err</span><span class="o">.</span><span class="n">river_seg</span> <span class="o">=</span> <span class="n">parent_node</span><span class="o">.</span><span class="n">segment</span>
                <span class="n">err</span><span class="o">.</span><span class="n">river</span> <span class="o">=</span> <span class="n">river</span>
                <span class="n">err</span><span class="o">.</span><span class="n">huc_segment</span> <span class="o">=</span> <span class="n">seg</span>
                <span class="k">raise</span> <span class="n">err</span>

            <span class="k">if</span> <span class="n">outlet_junction</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;  found outlet junction&#39;</span><span class="p">)</span>
                <span class="n">elem</span> <span class="o">=</span> <span class="n">parent_node</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">elem</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">id</span> <span class="o">-</span> <span class="n">gid_shift</span><span class="p">)</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">]</span>

                <span class="c1"># rc points at junction</span>
                <span class="n">rc_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">river_corr</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">elem</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]]</span>

                <span class="c1"># reference segment for angles</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent_node</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">ref_seg</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">LineString</span><span class="p">(</span>
                        <span class="n">parent_node</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">ind_intersection_point</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ref_seg</span> <span class="o">=</span> <span class="n">parent_node</span><span class="o">.</span><span class="n">segment</span>

                <span class="c1"># orientations of hucs-segments</span>
                <span class="n">seg_angles</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">angle_rivers_segs</span><span class="p">(</span><span class="n">ref_seg</span><span class="p">,</span> <span class="n">hucs</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">seg_id</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">seg_id</span> <span class="ow">in</span> <span class="n">intersection_segs</span>
                <span class="p">]</span>
                <span class="n">incoming_river_angles</span> <span class="o">=</span> <span class="p">[</span><span class="mi">180</span><span class="p">,</span> <span class="p">]</span>  <span class="c1"># this hardcoded only for outlet junction</span>

                <span class="c1"># all line segments (hucs-segments and river-segments) at this junction</span>
                <span class="n">all_segs</span> <span class="o">=</span> <span class="n">intersection_segs</span> <span class="o">+</span> <span class="p">[</span><span class="n">parent_node</span><span class="p">,</span> <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># internal junction</span>
                <span class="n">rc_points</span> <span class="o">=</span> <span class="n">rc_points_for_rt_point</span><span class="p">(</span><span class="n">intersection_point</span><span class="p">,</span> <span class="n">parent_node</span><span class="p">,</span> <span class="n">river_corr</span><span class="p">)</span>

                <span class="c1"># this is small part of the parent node.segment just downstream of the intersection point</span>
                <span class="n">ref_seg</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">LineString</span><span class="p">(</span>
                    <span class="n">parent_node</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">ind_intersection_point</span><span class="p">:</span><span class="n">ind_intersection_point</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
                <span class="n">seg_angles</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">angle_rivers_segs</span><span class="p">(</span><span class="n">ref_seg</span><span class="p">,</span> <span class="n">hucs</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">seg_id</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">seg_id</span> <span class="ow">in</span> <span class="n">intersection_segs</span>
                <span class="p">]</span>

                <span class="c1"># orientations of incoming river-segments</span>
                <span class="k">if</span> <span class="n">intersection_point</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span>
                        <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">parent_node</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                    <span class="c1"># huc and rt intersect at river-merging point</span>
                    <span class="n">incoming_river_angles</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">angle_rivers_segs</span><span class="p">(</span><span class="n">ref_seg</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">parent_node</span><span class="o">.</span><span class="n">children</span>
                    <span class="p">]</span>
                    <span class="n">all_segs</span> <span class="o">=</span> <span class="n">intersection_segs</span> <span class="o">+</span> <span class="n">parent_node</span><span class="o">.</span><span class="n">children</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">upstream_seg</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">LineString</span><span class="p">(</span>
                        <span class="n">parent_node</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">ind_intersection_point</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">ind_intersection_point</span>
                                                   <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">incoming_river_angles</span> <span class="o">=</span> <span class="p">[</span><span class="n">angle_rivers_segs</span><span class="p">(</span><span class="n">ref_seg</span><span class="p">,</span> <span class="n">upstream_seg</span><span class="p">),</span> <span class="p">]</span>
                    <span class="n">all_segs</span> <span class="o">=</span> <span class="n">intersection_segs</span> <span class="o">+</span> <span class="p">[</span><span class="n">parent_node</span><span class="p">,</span> <span class="p">]</span>

            <span class="c1"># orientation of all line segments (hucs-segments and river-segments) at this junction</span>
            <span class="n">all_angles</span> <span class="o">=</span> <span class="n">seg_angles</span> <span class="o">+</span> <span class="n">incoming_river_angles</span>

            <span class="n">junction_seg_angles</span> <span class="o">=</span> <span class="p">{</span><span class="n">all_segs</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">all_angles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_segs</span><span class="p">))}</span>

            <span class="c1"># sort segments by their orientation angles</span>
            <span class="n">junction_seg_angles_sorted</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="nb">sorted</span><span class="p">(</span><span class="n">junction_seg_angles</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

            <span class="c1"># This polygon is used to remove overlapping</span>
            <span class="c1"># huc-segment and river corridor. To avoid issues at</span>
            <span class="c1"># snapped leaf node intersecting with this with this</span>
            <span class="c1"># huc segment, we create local river corridor polygon</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="n">parent_node</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">id</span> <span class="o">-</span> <span class="n">gid_shift</span><span class="p">)</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">]</span>
            <span class="n">river_corr_part</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span>
                <span class="p">[</span><span class="n">river_corr</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">elem</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]]</span> <span class="o">+</span> <span class="n">rc_points</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">integrate_rc</span> <span class="ow">or</span> <span class="n">outlet_junction</span><span class="p">:</span>
                <span class="c1"># Modify the huc boundary to integrate quad edges</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hucs</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">hucs</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjust_seg_for_rc</span><span class="p">(</span><span class="n">hucs</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">river_corr_part</span><span class="p">,</span>
                                                           <span class="n">rc_points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">hucs</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjust_seg_for_rc</span><span class="p">(</span><span class="n">hucs</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">river_corr_part</span><span class="p">,</span>
                                                           <span class="n">rc_points</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># identify which river corridor point is added to hucs-segment</span>
                    <span class="n">rc_point_ind</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">junction_seg_angles_sorted</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
                            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  modifying HUC segment </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="c1"># removing part of huc-segment overlappig with rc and snapping huc-segment end to &quot;right&quot; rc point</span>
                            <span class="n">hucs</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjust_seg_for_rc</span><span class="p">(</span><span class="n">hucs</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                                                                   <span class="n">river_corr_part</span><span class="p">,</span>
                                                                   <span class="n">rc_points</span><span class="p">[</span><span class="n">rc_point_ind</span><span class="p">])</span>
                            <span class="n">key_hold</span> <span class="o">=</span> <span class="n">key</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">rc_point_ind</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="c1"># extending huc-segment along smaller edge of the quad</span>
                            <span class="n">hucs</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">key_hold</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjust_seg_for_rc</span><span class="p">(</span><span class="n">hucs</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">key_hold</span><span class="p">],</span>
                                                                        <span class="n">river_corr_part</span><span class="p">,</span>
                                                                        <span class="n">rc_points</span><span class="p">[</span><span class="n">rc_point_ind</span><span class="p">],</span>
                                                                        <span class="n">integrate_rc</span><span class="o">=</span><span class="n">integrate_rc</span>
                                                                        <span class="ow">or</span> <span class="n">outlet_junction</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Just remove the part of of the huc-segment overlapping with the river corridor</span>
                <span class="n">rc_point_ind</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">junction_seg_angles_sorted</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  modifying HUC Segment </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">hucs</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjust_seg_for_rc</span><span class="p">(</span><span class="n">hucs</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">river_corr_part</span><span class="p">,</span>
                                                               <span class="n">rc_points</span><span class="p">[</span><span class="n">rc_point_ind</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">rc_point_ind</span> <span class="o">+=</span> <span class="mi">1</span></div>



<div class="viewcode-block" id="triangle_split_points">
<a class="viewcode-back" href="../../mesh.html#watershed_workflow.river_mesh.triangle_split_points">[docs]</a>
<span class="k">def</span> <span class="nf">triangle_split_points</span><span class="p">(</span><span class="n">stream_triangles</span><span class="p">,</span> <span class="n">river_corrs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find additional points to split stream triangles.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    stream_triangles : list of tuples</span>
<span class="sd">        List of triangle vertices.</span>
<span class="sd">    river_corrs : list of shapely.geometry.Polygon</span>
<span class="sd">        List of river corridor polygons.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">river_corr</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">unary_union</span><span class="p">(</span><span class="n">river_corrs</span><span class="p">)</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">additional_points</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">tri_verts</span> <span class="ow">in</span> <span class="n">stream_triangles</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tri_verts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>

        <span class="c1"># Get midpoints of each edge</span>
        <span class="n">midpoints</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span>
                <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">midpoint</span><span class="p">(</span><span class="n">tri_verts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tri_verts</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="p">]</span>
        
        <span class="c1"># Check which midpoints lie on river corridors</span>
        <span class="n">off_corridor</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">ip</span><span class="p">:</span> <span class="ow">not</span> <span class="n">river_corr</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">ip</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">midpoints</span><span class="p">)))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">off_corridor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">edge_i</span> <span class="o">=</span> <span class="n">off_corridor</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">edge_midpoint</span> <span class="o">=</span> <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">midpoint</span><span class="p">(</span><span class="n">tri_verts</span><span class="p">[</span><span class="n">edge_i</span><span class="p">],</span>
                                                              <span class="n">tri_verts</span><span class="p">[(</span><span class="n">edge_i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span>
            <span class="n">additional_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_midpoint</span><span class="p">)</span>
                
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">off_corridor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">edge_lengths</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">tri_verts</span><span class="p">[</span><span class="n">off_corridor</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> 
                                                    <span class="n">tri_verts</span><span class="p">[(</span><span class="n">off_corridor</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="p">]</span>          
            <span class="c1"># Select the midpoint on the longer edge</span>
            <span class="n">longer_edge_index</span> <span class="o">=</span> <span class="n">edge_lengths</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">edge_lengths</span><span class="p">))</span>
            <span class="n">edge_i</span> <span class="o">=</span> <span class="n">off_corridor</span><span class="p">[</span><span class="n">longer_edge_index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">edge_midpoint</span> <span class="o">=</span> <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">midpoint</span><span class="p">(</span><span class="n">tri_verts</span><span class="p">[</span><span class="n">edge_i</span><span class="p">],</span>
                                                                <span class="n">tri_verts</span><span class="p">[(</span><span class="n">edge_i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span>
            <span class="n">additional_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_midpoint</span><span class="p">)</span>
     
    <span class="c1"># Remove coinciding points</span>
    <span class="n">unique_points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">additional_points</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">unique_points</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-202X, UT Battelle, Ethan Coon.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>