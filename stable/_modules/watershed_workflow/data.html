
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>watershed_workflow.data &#8212; Watershed Workflow</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css?v=6644e6bb" />
    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/2.0.8/css/dataTables.dataTables.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/custom_theme.css" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../../_static/documentation_options.js?v=3ce10a4d"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/watershed_workflow/data';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.16.1';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = 'https://raw.githubusercontent.com/environmental-modeling-workflows/watershed-workflow/master/docs/source/_static/versions.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = 'v2.0';
        DOCUMENTATION_OPTIONS.show_version_warning_banner =
            false;
        </script>
    <script src="https://cdn.datatables.net/2.0.8/js/dataTables.js"></script>
    <script src="../../_static/main.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="dev" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">Watershed Workflow</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../intro.html">
    Introduction
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../examples/mesh_coweeta.html">
    Example: mesh a delineated watershed
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../install.html">
    Installation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../concepts.html">
    Concepts
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api.html">
    API Documentation
  </a>
</li>

            <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button"
                data-bs-toggle="dropdown" aria-expanded="false"
                aria-controls="pst-nav-more-links">
                    More
                </button>
                <ul id="pst-nav-more-links" class="dropdown-menu">
                    
<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../gallery.html">
    Gallery
  </a>
</li>

                </ul>
            </li>
            
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../intro.html">
    Introduction
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../examples/mesh_coweeta.html">
    Example: mesh a delineated watershed
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../install.html">
    Installation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../concepts.html">
    Concepts
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api.html">
    API Documentation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../gallery.html">
    Gallery
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item"><!-- This will display the version of the docs -->
Version dev</div>
        <div class="sidebar-primary-item">
<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-2"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-2"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-2"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-2">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>
    
    
    <li class="breadcrumb-item"><a href="../watershed_workflow.html" class="nav-link">watershed_workflow</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">watershed_workflow.data</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for watershed_workflow.data</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Functions used in interacting with data, either pandas DataFrames or xarray DataArrays.&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">overload</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">xarray.core.types</span><span class="w"> </span><span class="kn">import</span> <span class="n">InterpOptions</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">npt</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cftime</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">datetime</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">rasterio.transform</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">rasterio.features</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">shapely.geometry</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.signal</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.stats</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.ndimage</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.interpolate</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">watershed_workflow.crs</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">watershed_workflow.crs</span><span class="w"> </span><span class="kn">import</span> <span class="n">CRS</span>

<span class="n">ValidTime</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">cftime</span><span class="o">.</span><span class="n">_cftime</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">]</span>

<span class="c1">#</span>
<span class="c1"># Helper functions</span>
<span class="c1">#</span>
<div class="viewcode-block" id="convertTimesToCFTime">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.convertTimesToCFTime">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">convertTimesToCFTime</span><span class="p">(</span><span class="n">time_values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ValidTime</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">cftime</span><span class="o">.</span><span class="n">_cftime</span><span class="o">.</span><span class="n">datetime</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert an iterable of datetime objects to cftime object.</span>
<span class="sd">    </span>
<span class="sd">    This function accepts various datetime types and converts them to</span>
<span class="sd">    cftime Gregorian calendar.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time_values</span>
<span class="sd">        Iterable of datetime objects (numpy datetime64, pandas Timestamp, </span>
<span class="sd">        Python datetime, or cftime objects). All elements must be the same type.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    List[cftime._cftime.datetime]</span>
<span class="sd">        List of cftime objects, likely in the Gregorian calendar.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Handle empty input</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cftime</span><span class="o">.</span><span class="n">DatetimeGregorian</span><span class="p">)</span>

    <span class="c1"># Get a sample time and conditional on type</span>
    <span class="n">sample_time</span> <span class="o">=</span> <span class="n">time_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sample_time</span><span class="p">,</span> <span class="n">cftime</span><span class="o">.</span><span class="n">_cftime</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">time_values</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sample_time</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">)):</span>
        <span class="n">time_values</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">time_values</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Cannot convert items of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">time_values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s1"> to cftime.&#39;</span><span class="p">)</span>

    <span class="c1"># convert pd.Timestamp to cftime</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">cftime</span><span class="o">.</span><span class="n">DatetimeGregorian</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">second</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">microsecond</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">time_values</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span></div>



<div class="viewcode-block" id="convertTimesToCFTimeNoleap">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.convertTimesToCFTimeNoleap">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">convertTimesToCFTimeNoleap</span><span class="p">(</span><span class="n">time_values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">cftime</span><span class="o">.</span><span class="n">_cftime</span><span class="o">.</span><span class="n">datetime</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">cftime</span><span class="o">.</span><span class="n">DatetimeNoLeap</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert an iterable of cftime objects on any calendar to cftime DatetimeNoLeap calendar.</span>
<span class="sd">    </span>
<span class="sd">    This function accepts various datetime types and converts them to cftime NoLeap</span>
<span class="sd">    calendar while preserving the input container type. Raises an error if any</span>
<span class="sd">    input date represents the 366th day of a year (leap day in DayMet convention).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time_values</span>
<span class="sd">        Sequence of datetime objects (numpy datetime64, pandas Timestamp, </span>
<span class="sd">        Python datetime, or cftime objects). All elements must be the same type.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Container of cftime.DatetimeNoLeap objects.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If any date in the input represents the 366th day of a year (leap day).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cftime</span><span class="o">.</span><span class="n">DatetimeNoLeap</span><span class="p">)</span>

    <span class="n">dayofyr</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">dayofyr</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">time_values</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">dayofyr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">366</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input contains leap day(s) (366th day of year)&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="n">cftime</span><span class="o">.</span><span class="n">DatetimeNoLeap</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">second</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">microsecond</span><span class="p">)</span>
        <span class="o">+</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">dayofyr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">time_values</span>
    <span class="p">])</span></div>



<div class="viewcode-block" id="createNoleapMask">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.createNoleapMask">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">createNoleapMask</span><span class="p">(</span><span class="n">time_values</span> <span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ValidTime</span><span class="p">]</span>
                     <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">cftime</span><span class="o">.</span><span class="n">DatetimeNoLeap</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a mask that is true for any non-leap-day (day 366).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time_values : Sequence[ValidTime]</span>
<span class="sd">        Time values to filter for leap days.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Sequence[cftime.DatetimeNoLeap]</span>
<span class="sd">        Time values converted to cftime format with leap days filtered.</span>
<span class="sd">    List[bool]</span>
<span class="sd">        Boolean mask where True indicates non-leap days.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># no times --&gt; no leap days</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>

    <span class="c1"># cftime.DataNoleap --&gt; no leap days</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cftime</span><span class="o">.</span><span class="n">DatetimeNoLeap</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">time_values</span><span class="p">,</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_values</span><span class="p">)</span>

    <span class="c1"># Get the time column is in cftime format</span>
    <span class="n">time_in_cftime</span> <span class="o">=</span> <span class="n">convertTimesToCFTime</span><span class="p">(</span><span class="n">time_values</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">t</span><span class="o">.</span><span class="n">dayofyr</span> <span class="o">!=</span> <span class="mi">366</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">time_in_cftime</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">time_in_cftime</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">mask</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_convertDataFrameToDataset</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">time_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert DataFrame to Dataset for shared processing.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pandas.DataFrame</span>
<span class="sd">        Input DataFrame containing time series data.</span>
<span class="sd">    time_column : str</span>
<span class="sd">        Name of the time column.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dataset : xarray.Dataset</span>
<span class="sd">        Dataset containing the converted data.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If time_column not found or no numeric columns available.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">time_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column &#39;</span><span class="si">{</span><span class="n">time_column</span><span class="si">}</span><span class="s2">&#39; not found in DataFrame&quot;</span><span class="p">)</span>

    <span class="c1"># Sort by time</span>
    <span class="n">df_sorted</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">time_column</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Get all numeric columns except time column</span>
    <span class="n">numeric_cols</span> <span class="o">=</span> <span class="n">df_sorted</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">columns_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">numeric_cols</span> <span class="k">if</span> <span class="n">col</span> <span class="o">!=</span> <span class="n">time_column</span><span class="p">]</span>

    <span class="c1"># Create Dataset from numeric columns</span>
    <span class="n">data_vars</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns_out</span><span class="p">:</span>
        <span class="n">data_vars</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">df_sorted</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                      <span class="n">coords</span><span class="o">=</span><span class="p">{</span> <span class="n">time_column</span><span class="p">:</span> <span class="n">df_sorted</span><span class="p">[</span><span class="n">time_column</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="p">},</span>
                                      <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="n">time_column</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_vars</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No numeric columns provided or found.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">data_vars</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_convertDatasetToDataFrame</span><span class="p">(</span><span class="n">ds</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span> <span class="n">time_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">output_times</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert Dataset back to DataFrame format.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ds : xarray.Dataset</span>
<span class="sd">        Input Dataset to convert.</span>
<span class="sd">    time_column : str</span>
<span class="sd">        Name of the time column to use.</span>
<span class="sd">    output_times : pandas.Series</span>
<span class="sd">        Time values to use for the output DataFrame.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        Converted DataFrame with time column first, then other columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result_df</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">result_df</span><span class="p">[</span><span class="n">time_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_times</span>
    <span class="k">return</span> <span class="n">result_df</span>


<div class="viewcode-block" id="computeMode">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.computeMode">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">computeMode</span><span class="p">(</span><span class="n">da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the mode along the time dimension of a DataArray.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    da : xr.DataArray</span>
<span class="sd">        Input DataArray. Can contain any data type that scipy.stats.mode can handle.</span>
<span class="sd">    time_dim : str, optional</span>
<span class="sd">        Name of the time dimension along which to compute the mode. Default is &#39;time&#39;.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xr.DataArray</span>
<span class="sd">        DataArray with the mode computed along the time dimension. The time dimension</span>
<span class="sd">        is removed from the output. All other dimensions, coordinates, and attributes</span>
<span class="sd">        are preserved. In case of multiple modes, returns the smallest value.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the specified time dimension is not found in the DataArray.</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For continuous data, the mode may not be meaningful. This function is most</span>
<span class="sd">    useful for discrete or categorical data.</span>
<span class="sd">    </span>
<span class="sd">    When multiple values have the same highest frequency (multiple modes), </span>
<span class="sd">    scipy.stats.mode returns the smallest of these values.</span>
<span class="sd">    </span>
<span class="sd">    NaN values are ignored in the mode calculation.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">time_dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Data must have a &#39;</span><span class="si">{</span><span class="n">time_dim</span><span class="si">}</span><span class="s2">&#39; dimension&quot;</span><span class="p">)</span>

    <span class="c1"># Get the axis number for time dimension</span>
    <span class="n">time_axis</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">time_dim</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
        <span class="c1"># For numeric data, use scipy.stats.mode</span>
        <span class="n">mode_result</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">time_axis</span><span class="p">,</span> <span class="n">nan_policy</span><span class="o">=</span><span class="s1">&#39;omit&#39;</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">mode_values</span> <span class="o">=</span> <span class="n">mode_result</span><span class="o">.</span><span class="n">mode</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Non-numeric data modes are not implemented.&#39;</span><span class="p">)</span>

    <span class="c1"># Create coordinates for the result (all except time dimension)</span>
    <span class="n">new_coords</span> <span class="o">=</span> <span class="p">{</span> <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">time_dim</span> <span class="p">}</span>

    <span class="c1"># Create new dimensions list (all except time dimension)</span>
    <span class="n">new_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span> <span class="k">if</span> <span class="n">d</span> <span class="o">!=</span> <span class="n">time_dim</span><span class="p">]</span>

    <span class="c1"># Create result DataArray</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">mode_values</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">new_dims</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">new_coords</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">da</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

    <span class="c1"># transfer the crs</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">crs</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">crs</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">crs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">write_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Preserve the name if it exists</span>
    <span class="k">if</span> <span class="n">da</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">da</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_mode&quot;</span>

    <span class="k">return</span> <span class="n">result</span></div>



<span class="c1">#</span>
<span class="c1"># filter leap day</span>
<span class="c1">#</span>
<div class="viewcode-block" id="filterLeapDay_DataFrame">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.filterLeapDay_DataFrame">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">filterLeapDay_DataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">time_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remove day 366 (Dec 31) from leap years and convert time column to CFTime noleap calendar.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df</span>
<span class="sd">        Input DataFrame containing time series data.</span>
<span class="sd">    time_column</span>
<span class="sd">        Name of the column containing datetime data. Must be convertible to pandas datetime.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        DataFrame with day 366 of leap years removed and time column converted to </span>
<span class="sd">        cftime noleap calendar format.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `time_column` is not found in the DataFrame.</span>
<span class="sd">        If the time column cannot be converted to datetime format.</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Day 366 only occurs on December 31st in leap years. The function assumes that</span>
<span class="sd">    the input time column is not already in cftime noleap format, as noleap </span>
<span class="sd">    calendars by definition do not have day 366.</span>
<span class="sd">    </span>
<span class="sd">    The DataFrame index is reset after filtering to ensure continuous indexing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Validate inputs</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">time_series</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">time_column</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column &#39;</span><span class="si">{</span><span class="n">time_column</span><span class="si">}</span><span class="s2">&#39; not found in DataFrame&quot;</span><span class="p">)</span>

    <span class="c1"># no times --&gt; no leap days</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_series</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="c1"># cftime.DataNoleap --&gt; no leap days</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_series</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cftime</span><span class="o">.</span><span class="n">DatetimeNoLeap</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="c1"># Get the time column is in cftime format, and a mask that is True for any non-leap-days</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">time_series_cftime</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">createNoleapMask</span><span class="p">(</span><span class="n">time_series</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not convert column &#39;</span><span class="si">{</span><span class="n">time_column</span><span class="si">}</span><span class="s2">&#39; to cftime: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Apply the filter</span>
    <span class="n">df_filtered</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Convert the time column to CFTime noleap calendar</span>
    <span class="n">df_filtered</span><span class="p">[</span><span class="n">time_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">convertTimesToCFTimeNoleap</span><span class="p">(</span><span class="n">time_series_cftime</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df_filtered</span></div>



<div class="viewcode-block" id="filterLeapDay_xarray">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.filterLeapDay_xarray">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">filterLeapDay_xarray</span><span class="p">(</span><span class="n">da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
                         <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remove day 366 (Dec 31) from leap years and convert time dimension to CFTime noleap calendar.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    da : xr.DataArray</span>
<span class="sd">        Input DataArray with a time dimension. The time dimension must contain</span>
<span class="sd">        datetime-like values that can be converted to pandas datetime.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xr.DataArray</span>
<span class="sd">        DataArray with day 366 of leap years removed and time dimension converted to </span>
<span class="sd">        cftime noleap calendar format. All attributes, including rasterio-specific</span>
<span class="sd">        attributes like &#39;nodata&#39; and &#39;crs&#39;, are preserved.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the DataArray does not have a &#39;time&#39; dimension.</span>
<span class="sd">        If the time dimension cannot be converted to datetime format.</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Day 366 only occurs on December 31st in leap years. The function assumes that</span>
<span class="sd">    the input time dimension is not already in cftime noleap format, as noleap </span>
<span class="sd">    calendars by definition do not have day 366.</span>
<span class="sd">    </span>
<span class="sd">    For rasterio-based DataArrays, this function preserves the coordinate reference</span>
<span class="sd">    system (CRS) and nodata value attributes. All other attributes are also preserved.</span>
<span class="sd">    </span>
<span class="sd">    The time dimension name is preserved, but its values are replaced with cftime</span>
<span class="sd">    noleap calendar objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># deal with missing time_dim</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">time_series</span> <span class="o">=</span> <span class="n">da</span><span class="p">[</span><span class="n">time_dim</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Data must have a &#39;</span><span class="si">{</span><span class="n">time_dim</span><span class="si">}</span><span class="s2">&#39; dimension&quot;</span><span class="p">)</span>

    <span class="c1"># deal with empty time_dim</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_series</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">da</span>

    <span class="c1"># Create mask for values to keep (exclude day 366 in leap years)</span>
    <span class="n">time_array_cftime</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">createNoleapMask</span><span class="p">(</span><span class="n">time_series</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="c1"># Apply the filter to the DataArray</span>
    <span class="n">da_filtered</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">isel</span><span class="p">({</span> <span class="n">time_dim</span><span class="p">:</span> <span class="n">mask</span> <span class="p">})</span>

    <span class="c1"># Convert the filtered time values to cftime noleap</span>
    <span class="n">time_array_noleap</span> <span class="o">=</span> <span class="n">convertTimesToCFTimeNoleap</span><span class="p">(</span><span class="n">time_array_cftime</span><span class="p">)</span>

    <span class="c1"># Replace the time coordinate with cftime noleap</span>
    <span class="n">da_filtered</span> <span class="o">=</span> <span class="n">da_filtered</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span> <span class="n">time_dim</span><span class="p">:</span> <span class="n">time_array_noleap</span> <span class="p">})</span>

    <span class="c1"># Preserve all attributes from the original DataArray</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">crs</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">crs</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">crs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">da_filtered</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">write_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">da_filtered</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Preserve coordinate attributes (including CRS if present)</span>
    <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">da_filtered</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">coords</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">coord</span><span class="p">],</span> <span class="s1">&#39;attrs&#39;</span><span class="p">):</span>
            <span class="n">da_filtered</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Preserve attributes for all variables in a Dataset</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">da_filtered</span><span class="p">,</span> <span class="s1">&#39;data_vars&#39;</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">da_filtered</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">data_vars</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">da</span><span class="p">[</span><span class="n">var</span><span class="p">],</span> <span class="s1">&#39;attrs&#39;</span><span class="p">):</span>
                <span class="n">da_filtered</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">da</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">da_filtered</span></div>



<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">filterLeapDay</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span> <span class="n">time_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">filterLeapDay</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">time_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">filterLeapDay</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">time_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="filterLeapDay">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.filterLeapDay">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">filterLeapDay</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">],</span>
                  <span class="n">time_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remove day 366 (Dec 31) from leap years and convert time to CFTime noleap calendar.</span>
<span class="sd">    </span>
<span class="sd">    This function automatically selects the appropriate implementation based on the</span>
<span class="sd">    input data type: DataFrame, DataArray, or Dataset.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : pandas.DataFrame, xr.DataArray, or xr.Dataset</span>
<span class="sd">        Input data containing time series information to filter.</span>
<span class="sd">    time_column : str, optional</span>
<span class="sd">        For DataFrame: Name of the column containing datetime data (required).</span>
<span class="sd">        For Dataset: Name of the time dimension (defaults to &#39;time&#39;).</span>
<span class="sd">        For DataArray: Ignored (always uses &#39;time&#39; dimension).</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame, xr.DataArray, or xr.Dataset</span>
<span class="sd">        Same type as input with day 366 of leap years removed and time </span>
<span class="sd">        converted to cftime noleap calendar format.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If data is not a DataFrame, DataArray, or Dataset.</span>
<span class="sd">        If DataFrame is provided without time_column.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If time column/dimension is not found or cannot be converted to datetime.</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Day 366 only occurs on December 31st in leap years. The function assumes that</span>
<span class="sd">    the input time data is not already in cftime noleap format, as noleap </span>
<span class="sd">    calendars by definition do not have day 366.</span>
<span class="sd">    </span>
<span class="sd">    For DataFrames:</span>
<span class="sd">        - time_column parameter is required</span>
<span class="sd">        - DataFrame index is reset after filtering</span>
<span class="sd">        </span>
<span class="sd">    For DataArrays &amp; Datasets:</span>
<span class="sd">        - time_column parameter specifies the time dimension (default: &#39;time&#39;)</span>
<span class="sd">        - All attributes including rasterio-specific ones are preserved</span>
<span class="sd">        </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    filterLeapDay_DataFrame : DataFrame-specific implementation</span>
<span class="sd">    filterLeapDay_DataArray : DataArray-specific implementation  </span>
<span class="sd">    filterLeapDay_Dataset : Dataset-specific implementation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)):</span>
        <span class="c1"># Dataset can use custom time dimension name</span>
        <span class="k">return</span> <span class="n">filterLeapDay_xarray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">time_dim</span><span class="o">=</span><span class="n">time_column</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">time_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;time_column parameter is required for DataFrame input&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">filterLeapDay_DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">time_column</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input data must be a pandas DataFrame, xr DataArray, or xr Dataset. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="interpolate_Dataset">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.interpolate_Dataset">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">interpolate_Dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
                        <span class="n">time_values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ValidTime</span><span class="p">],</span>
                        <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span>
                        <span class="n">method</span><span class="p">:</span> <span class="n">InterpOptions</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Interpolate Dataset to arbitrary times.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ds : xr.Dataset</span>
<span class="sd">        Input Dataset with a time dimension containing cftime objects.</span>
<span class="sd">    time_values : Sequence[ValidTime]</span>
<span class="sd">        Time values to interpolate to.</span>
<span class="sd">    time_dim : str</span>
<span class="sd">        Name of the time dimension. Default is &#39;time&#39;.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        Interpolation method. Default is &#39;linear&#39;.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xr.Dataset</span>
<span class="sd">        Dataset with regular time intervals and interpolated values.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If time dimension is not found or interval is not 1 or 5.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">time_dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Data must have a &#39;</span><span class="si">{</span><span class="n">time_dim</span><span class="si">}</span><span class="s2">&#39; dimension&quot;</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">interp</span><span class="p">({</span> <span class="n">time_dim</span><span class="p">:</span> <span class="n">time_values</span> <span class="p">},</span>
                       <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                       <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span> <span class="s1">&#39;fill_value&#39;</span><span class="p">:</span> <span class="s1">&#39;extrapolate&#39;</span><span class="p">}</span> <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;nearest&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="p">{})</span>
    
    <span class="c1"># Preserve Dataset attributes</span>
    <span class="n">result</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="interpolate_DataFrame">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.interpolate_DataFrame">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">interpolate_DataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
                          <span class="n">time_values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ValidTime</span><span class="p">],</span>
                          <span class="n">time_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span>
                          <span class="n">method</span><span class="p">:</span> <span class="n">InterpOptions</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Interpolate DataFrame to arbitrary times.</span>

<span class="sd">    NOTE: this is not the same as pandas.interpolate(), but more like</span>
<span class="sd">    pandas.reindex(time_values).interpolate() with scipy-based</span>
<span class="sd">    interpolation options.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pandas.DataFrame</span>
<span class="sd">        Input DataFrame with a time column containing cftime objects.</span>
<span class="sd">    time_values : Sequence[ValidTime]</span>
<span class="sd">        Time values to interpolate to.</span>
<span class="sd">    time_column : str</span>
<span class="sd">        Name of the column containing cftime datetime objects.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        Interpolation method. Default is &#39;linear&#39;.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        DataFrame with regular time intervals and interpolated values.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If time_column is not found or interval is not 1 or 5.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get a dataset</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="n">_convertDataFrameToDataset</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">time_column</span><span class="p">)</span>

    <span class="c1"># interpolate using dataset function</span>
    <span class="n">interp_ds</span> <span class="o">=</span> <span class="n">interpolate_Dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">time_values</span><span class="p">,</span> <span class="n">time_column</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

    <span class="c1"># Convert back to DataFrame</span>
    <span class="k">return</span> <span class="n">_convertDatasetToDataFrame</span><span class="p">(</span><span class="n">interp_ds</span><span class="p">,</span> <span class="n">time_column</span><span class="p">,</span> <span class="n">interp_ds</span><span class="p">[</span><span class="n">time_column</span><span class="p">])</span></div>




<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">interpolate</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
                <span class="n">time_values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ValidTime</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
                <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
                <span class="n">method</span><span class="p">:</span> <span class="n">InterpOptions</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">interpolate</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
                <span class="n">time_values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ValidTime</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
                <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
                <span class="n">method</span><span class="p">:</span> <span class="n">InterpOptions</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">interpolate</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
                <span class="n">time_values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ValidTime</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
                <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
                <span class="n">method</span><span class="p">:</span> <span class="n">InterpOptions</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="interpolate">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.interpolate">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">interpolate</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">],</span>
                <span class="n">time_values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ValidTime</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
                <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span>
                <span class="n">method</span><span class="p">:</span> <span class="n">InterpOptions</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>
                <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolate data to new times.</span>
<span class="sd">    </span>
<span class="sd">    This function automatically selects the appropriate implementation based on the</span>
<span class="sd">    input data type: DataFrame, DataArray, or Dataset.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : pandas.DataFrame, xr.DataArray, or xr.Dataset</span>
<span class="sd">        Input data containing time series with cftime calendar.</span>
<span class="sd">    time_values : Sequence[ValidTime]</span>
<span class="sd">        Time values to interpolate to.</span>
<span class="sd">    time_dim : str, optional</span>
<span class="sd">        For DataFrame: Name of the time column (required).</span>
<span class="sd">        For Dataset/DataArray: Name of the time dimension (default: &#39;time&#39;).</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        Interpolation method. Default is &#39;linear&#39;.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame, xr.DataArray, or xr.Dataset</span>
<span class="sd">        Same type as input with regular time intervals and interpolated values.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If data is not a DataFrame, DataArray, or Dataset.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If required parameters are missing or invalid.</span>
<span class="sd">        </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    interpolate_DataFrame : DataFrame-specific implementation</span>
<span class="sd">    interpolate_Dataset : Dataset-specific implementation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">interpolate_Dataset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">time_values</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">interpolate_DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">time_values</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input data must be a pandas DataFrame, xr DataArray, or xr Dataset. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="interpolateToRegular">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.interpolateToRegular">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">interpolateToRegular</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">],</span>
                         <span class="n">interval</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                         <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span>
                         <span class="n">method</span><span class="p">:</span> <span class="n">InterpOptions</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>
                         <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolate data to new times.</span>
<span class="sd">    </span>
<span class="sd">    This function automatically selects the appropriate implementation based on the</span>
<span class="sd">    input data type: DataFrame, DataArray, or Dataset.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : pandas.DataFrame, xr.DataArray, or xr.Dataset</span>
<span class="sd">        Input data containing time series with cftime calendar.</span>
<span class="sd">    time_values : Sequence[ValidTime]</span>
<span class="sd">        Time values to interpolate to.</span>
<span class="sd">    time_dim : str, optional</span>
<span class="sd">        For DataFrame: Name of the time column (required).</span>
<span class="sd">        For Dataset/DataArray: Name of the time dimension (default: &#39;time&#39;).</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        Interpolation method. Default is &#39;linear&#39;.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame, xr.DataArray, or xr.Dataset</span>
<span class="sd">        Same type as input with regular time intervals and interpolated values.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If data is not a DataFrame, DataArray, or Dataset.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If required parameters are missing or invalid.</span>
<span class="sd">        </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    interpolate_DataFrame : DataFrame-specific implementation</span>
<span class="sd">    interpolate_Dataset : Dataset-specific implementation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start_year</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">time_dim</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">year</span>
    <span class="n">end_year</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">time_dim</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">year</span>

    <span class="n">calendar</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">time_dim</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cftime</span><span class="o">.</span><span class="n">DatetimeNoLeap</span><span class="p">):</span>
        <span class="n">calendar</span> <span class="o">=</span> <span class="s1">&#39;noleap&#39;</span>
        
    <span class="n">new_times</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">time_dim</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">time_dim</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">freq</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">interval</span><span class="si">}</span><span class="s1">D&#39;</span><span class="p">,</span> <span class="n">calendar</span><span class="o">=</span><span class="n">calendar</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">new_times</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span></div>

    

<span class="c1">#</span>
<span class="c1"># Compute an annual average</span>
<span class="c1">#</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_computeAverageYear</span><span class="p">(</span><span class="n">ds</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">start_date</span><span class="p">:</span> <span class="n">cftime</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span>
                        <span class="n">output_nyears</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">cftime</span><span class="o">.</span><span class="n">datetime</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute annual average for a Dataset and generate output times.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ds : xr.Dataset</span>
<span class="sd">        Input Dataset with cftime noleap calendar dates.</span>
<span class="sd">    time_dim : str</span>
<span class="sd">        Name of the time dimension.</span>
<span class="sd">    start_date : cftime.datetime</span>
<span class="sd">        Start date for the output time series.</span>
<span class="sd">    output_nyears : int</span>
<span class="sd">        Number of years to repeat the averaged pattern.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    averaged_ds : xr.Dataset</span>
<span class="sd">        Dataset with averaged values indexed by day of year.</span>
<span class="sd">    output_times : list of cftime.datetime</span>
<span class="sd">        List of output times for the repeated pattern.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Calculate day of year for each time point</span>
    <span class="n">time_values</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">time_dim</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">doys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">date</span> <span class="o">-</span> <span class="n">cftime</span><span class="o">.</span><span class="n">DatetimeNoLeap</span><span class="p">(</span><span class="n">date</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">days</span> <span class="o">+</span> <span class="mi">1</span>
                     <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">time_values</span><span class="p">])</span>

    <span class="c1"># Get unique days of year</span>
    <span class="n">unique_doys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">doys</span><span class="p">)</span>

    <span class="c1"># Add day of year coordinate temporarily</span>
    <span class="n">ds_with_doy</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">day_of_year</span><span class="o">=</span><span class="p">(</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">doys</span><span class="p">))</span>

    <span class="c1"># Group by day of year and compute mean</span>
    <span class="n">averaged_ds</span> <span class="o">=</span> <span class="n">ds_with_doy</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;day_of_year&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">time_dim</span><span class="p">)</span>

    <span class="c1"># Create output times</span>
    <span class="n">output_times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">output_doys</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">year_offset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">output_nyears</span><span class="p">):</span>
        <span class="n">current_year</span> <span class="o">=</span> <span class="n">start_date</span><span class="o">.</span><span class="n">year</span> <span class="o">+</span> <span class="n">year_offset</span>

        <span class="k">for</span> <span class="n">doy</span> <span class="ow">in</span> <span class="n">unique_doys</span><span class="p">:</span>
            <span class="n">date</span> <span class="o">=</span> <span class="n">cftime</span><span class="o">.</span><span class="n">DatetimeNoLeap</span><span class="p">(</span><span class="n">current_year</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">doy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">output_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
            <span class="n">output_doys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">doy</span><span class="p">)</span>

    <span class="c1"># Create mapping from output indices to day of year</span>
    <span class="n">output_doys_array</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">output_doys</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;new_time&#39;</span><span class="p">])</span>

    <span class="c1"># Create result by selecting appropriate days</span>
    <span class="n">result_ds</span> <span class="o">=</span> <span class="n">averaged_ds</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">day_of_year</span><span class="o">=</span><span class="n">output_doys_array</span><span class="p">)</span>
    <span class="n">result_ds</span> <span class="o">=</span> <span class="n">result_ds</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span> <span class="s1">&#39;new_time&#39;</span><span class="p">:</span> <span class="n">time_dim</span> <span class="p">})</span>

    <span class="c1"># Drop day_of_year coordinate</span>
    <span class="k">if</span> <span class="s1">&#39;day_of_year&#39;</span> <span class="ow">in</span> <span class="n">result_ds</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
        <span class="n">result_ds</span> <span class="o">=</span> <span class="n">result_ds</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;day_of_year&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result_ds</span><span class="p">,</span> <span class="n">output_times</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_parseStartDate</span><span class="p">(</span>
        <span class="n">start_date</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span> <span class="n">cftime</span><span class="o">.</span><span class="n">datetime</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">cftime</span><span class="o">.</span><span class="n">datetime</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse start_date into cftime.DatetimeNoLeap.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    start_date : str, datetime, or cftime.datetime</span>
<span class="sd">        Start date in various formats.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cftime.DatetimeNoLeap</span>
<span class="sd">        Parsed start date.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">start_date</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">start_date</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">start_date</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">month</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">day</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">cftime</span><span class="o">.</span><span class="n">DatetimeNoLeap</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cftime</span><span class="o">.</span><span class="n">DatetimeNoLeap</span><span class="p">(</span><span class="n">start_date</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">start_date</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">start_date</span><span class="o">.</span><span class="n">day</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">start_date</span>


<div class="viewcode-block" id="computeAverageYear_DataFrame">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.computeAverageYear_DataFrame">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">computeAverageYear_DataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
                                 <span class="n">time_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span>
                                 <span class="n">start_date</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span>
                                                   <span class="n">cftime</span><span class="o">.</span><span class="n">datetime</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;2020-1-1&#39;</span><span class="p">,</span>
                                 <span class="n">output_nyears</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Average DataFrame values across years and repeat for specified number of years.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pandas.DataFrame</span>
<span class="sd">        Input DataFrame with cftime noleap calendar dates at 1- or 5-day intervals.</span>
<span class="sd">    time_column : str</span>
<span class="sd">        Name of the column containing cftime datetime objects.</span>
<span class="sd">    start_date : str, datetime, or cftime.datetime</span>
<span class="sd">        Start date for the output time series. If string, should be &#39;YYYY-MM-DD&#39; format.</span>
<span class="sd">    output_nyears : int</span>
<span class="sd">        Number of years to repeat the averaged pattern.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        DataFrame with averaged values repeated for the specified number of years,</span>
<span class="sd">        starting from start_date. Only includes the time column and averaged numeric columns.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If time_column is not found or contains invalid data.</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The function computes the average value for each day of year (1-365) across all</span>
<span class="sd">    years in the input data. For 5-day intervals, it averages values at days 1, 6,</span>
<span class="sd">    11, etc. The resulting pattern is then repeated for output_nyears starting from</span>
<span class="sd">    start_date.</span>
<span class="sd">    </span>
<span class="sd">    Missing values (NaN) are ignored in the averaging process.</span>
<span class="sd">    Non-numeric columns are excluded from the output.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Parse start date</span>
    <span class="n">start_cftime</span> <span class="o">=</span> <span class="n">_parseStartDate</span><span class="p">(</span><span class="n">start_date</span><span class="p">)</span>

    <span class="c1"># get a dataset</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="n">_convertDataFrameToDataset</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">time_column</span><span class="p">)</span>

    <span class="c1"># Compute averages using shared function</span>
    <span class="n">averaged_ds</span><span class="p">,</span> <span class="n">output_times</span> <span class="o">=</span> <span class="n">_computeAverageYear</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">time_column</span><span class="p">,</span> <span class="n">start_cftime</span><span class="p">,</span> <span class="n">output_nyears</span><span class="p">)</span>

    <span class="c1"># Convert back to DataFrame</span>
    <span class="k">return</span> <span class="n">_convertDatasetToDataFrame</span><span class="p">(</span><span class="n">averaged_ds</span><span class="p">,</span> <span class="n">time_column</span><span class="p">,</span> <span class="n">output_times</span><span class="p">)</span></div>



<div class="viewcode-block" id="computeAverageYear_DataArray">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.computeAverageYear_DataArray">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">computeAverageYear_DataArray</span><span class="p">(</span><span class="n">da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
                                 <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span>
                                 <span class="n">start_date</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span>
                                                   <span class="n">cftime</span><span class="o">.</span><span class="n">datetime</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;2020-1-1&#39;</span><span class="p">,</span>
                                 <span class="n">output_nyears</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                                 <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Average DataArray values across years and repeat for specified number of years.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    da : xr.DataArray</span>
<span class="sd">        Input DataArray with cftime noleap calendar dates at 1- or 5-day intervals.</span>
<span class="sd">    start_date : str, datetime, or cftime.datetime</span>
<span class="sd">        Start date for the output time series. If string, should be &#39;YYYY-MM-DD&#39; format.</span>
<span class="sd">    output_nyears : int</span>
<span class="sd">        Number of years to repeat the averaged pattern.</span>
<span class="sd">    time_dim : str, optional</span>
<span class="sd">        Name of the time dimension. Default is &#39;time&#39;.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xr.DataArray</span>
<span class="sd">        DataArray with averaged values repeated for the specified number of years,</span>
<span class="sd">        starting from start_date. All attributes are preserved.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If time dimension is not found.</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The function computes the average value for each day of year (1-365) across all</span>
<span class="sd">    years in the input data. The resulting 365-day pattern is then repeated for</span>
<span class="sd">    output_nyears starting from start_date.</span>
<span class="sd">    </span>
<span class="sd">    This is particularly useful for creating climatological datasets or for</span>
<span class="sd">    generating synthetic time series based on historical patterns.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">time_dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Data must have a &#39;</span><span class="si">{</span><span class="n">time_dim</span><span class="si">}</span><span class="s2">&#39; dimension&quot;</span><span class="p">)</span>

    <span class="c1"># Parse start date</span>
    <span class="n">start_cftime</span> <span class="o">=</span> <span class="n">_parseStartDate</span><span class="p">(</span><span class="n">start_date</span><span class="p">)</span>

    <span class="c1"># Convert to Dataset for processing</span>
    <span class="n">temp_ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">({</span><span class="n">da</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">da</span><span class="p">})</span>

    <span class="c1"># Compute averages using shared function</span>
    <span class="n">averaged_ds</span><span class="p">,</span> <span class="n">output_times</span> <span class="o">=</span> <span class="n">_computeAverageYear</span><span class="p">(</span><span class="n">temp_ds</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">start_cftime</span><span class="p">,</span> <span class="n">output_nyears</span><span class="p">)</span>

    <span class="c1"># Extract the DataArray</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">averaged_ds</span><span class="p">[</span><span class="n">da</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s1">&#39;data&#39;</span><span class="p">]</span>

    <span class="c1"># Assign the output times</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span> <span class="n">time_dim</span><span class="p">:</span> <span class="n">output_times</span> <span class="p">})</span>

    <span class="c1"># Preserve attributes</span>
    <span class="n">result</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">name</span>

    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="computeAverageYear_Dataset">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.computeAverageYear_Dataset">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">computeAverageYear_Dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
                               <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span>
                               <span class="n">start_date</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span>
                                                 <span class="n">cftime</span><span class="o">.</span><span class="n">datetime</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;2020-1-1&#39;</span><span class="p">,</span>
                               <span class="n">output_nyears</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                               <span class="n">variables</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Average Dataset values across years and repeat for specified number of years.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ds : xr.Dataset</span>
<span class="sd">        Input Dataset with cftime noleap calendar dates at 1- or 5-day intervals.</span>
<span class="sd">    start_date : str, datetime, or cftime.datetime</span>
<span class="sd">        Start date for the output time series. If string, should be &#39;YYYY-MM-DD&#39; format.</span>
<span class="sd">    output_nyears : int</span>
<span class="sd">        Number of years to repeat the averaged pattern.</span>
<span class="sd">    time_dim : str, optional</span>
<span class="sd">        Name of the time dimension. Default is &#39;time&#39;.</span>
<span class="sd">    variables : list of str, optional</span>
<span class="sd">        List of variables to average. If None, averages all variables with the</span>
<span class="sd">        time dimension.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xr.Dataset</span>
<span class="sd">        Dataset with averaged values repeated for the specified number of years,</span>
<span class="sd">        starting from start_date. All attributes are preserved.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If time dimension is not found or if specified variables don&#39;t exist.</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Variables without the time dimension are preserved unchanged in the output.</span>
<span class="sd">    </span>
<span class="sd">    For each variable with the time dimension, the function computes the average</span>
<span class="sd">    value for each day of year across all years in the input data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">time_dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Data must have a &#39;</span><span class="si">{</span><span class="n">time_dim</span><span class="si">}</span><span class="s2">&#39; dimension&quot;</span><span class="p">)</span>

    <span class="c1"># Parse start date</span>
    <span class="n">start_cftime</span> <span class="o">=</span> <span class="n">_parseStartDate</span><span class="p">(</span><span class="n">start_date</span><span class="p">)</span>

    <span class="c1"># Select variables to process</span>
    <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vars_with_time</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">data_vars</span> <span class="k">if</span> <span class="n">time_dim</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">]</span>
        <span class="n">vars_without_time</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">data_vars</span> <span class="k">if</span> <span class="n">time_dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Validate variables</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">data_vars</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Variables not found in Dataset: </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">vars_with_time</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span> <span class="k">if</span> <span class="n">time_dim</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">]</span>
        <span class="n">vars_without_time</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">data_vars</span> <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">]</span>

    <span class="c1"># Create Dataset with only time-dependent variables</span>
    <span class="n">ds_to_avg</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">vars_with_time</span><span class="p">]</span> <span class="k">if</span> <span class="n">vars_with_time</span> <span class="k">else</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">vars_with_time</span><span class="p">:</span>
        <span class="c1"># Compute averages using shared function</span>
        <span class="n">averaged_ds</span><span class="p">,</span> <span class="n">output_times</span> <span class="o">=</span> <span class="n">_computeAverageYear</span><span class="p">(</span><span class="n">ds_to_avg</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">start_cftime</span><span class="p">,</span>
                                                        <span class="n">output_nyears</span><span class="p">)</span>

        <span class="c1"># Assign the output times</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">averaged_ds</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span> <span class="n">time_dim</span><span class="p">:</span> <span class="n">output_times</span> <span class="p">})</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># No time-dependent variables to average</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>

    <span class="c1"># Add variables without time dimension</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">vars_without_time</span><span class="p">:</span>
        <span class="n">result</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>

    <span class="c1"># Copy over other coordinates</span>
    <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">coord</span> <span class="o">!=</span> <span class="n">time_dim</span> <span class="ow">and</span> <span class="n">coord</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span>

    <span class="c1"># Preserve attributes</span>
    <span class="n">result</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">result</span></div>



<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">computeAverageYear</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
                       <span class="n">time_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                       <span class="n">start_year</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                       <span class="n">output_nyears</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">computeAverageYear</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
                       <span class="n">time_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                       <span class="n">start_year</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                       <span class="n">output_nyears</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">computeAverageYear</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
                       <span class="n">time_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                       <span class="n">start_year</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                       <span class="n">output_nyears</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="computeAverageYear">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.computeAverageYear">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">computeAverageYear</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">],</span>
        <span class="n">time_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">start_year</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">output_nyears</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Average data values across years and repeat for specified number of years.</span>
<span class="sd">    </span>
<span class="sd">    This function automatically selects the appropriate implementation based on the</span>
<span class="sd">    input data type: DataFrame, DataArray, or Dataset.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : pandas.DataFrame, xr.DataArray, or xr.Dataset</span>
<span class="sd">        Input data with cftime noleap calendar dates at 1- or 5-day intervals.</span>
<span class="sd">    time_column : str, optional</span>
<span class="sd">        For DataFrame: Name of the time column (required).</span>
<span class="sd">        For Dataset: Name of the time dimension (default: &#39;time&#39;).</span>
<span class="sd">        For DataArray: Ignored (always uses &#39;time&#39; dimension).</span>
<span class="sd">    start_year : int</span>
<span class="sd">        Start year for the output time series.</span>
<span class="sd">    output_nyears : int, optional</span>
<span class="sd">        Number of years to repeat the averaged pattern. Default is 1.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame, xr.DataArray, or xr.Dataset</span>
<span class="sd">        Same type as input with averaged values repeated for the specified number</span>
<span class="sd">        of years, starting from start_date.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If data is not a DataFrame, DataArray, or Dataset.</span>
<span class="sd">        If DataFrame is provided without time_column.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If time column/dimension is not found or contains invalid data.</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The function computes the average value for each day of year (1-365) across all</span>
<span class="sd">    years in the input data. For 5-day intervals, it averages values at days 1, 6,</span>
<span class="sd">    11, etc. The resulting pattern is then repeated for output_nyears starting from</span>
<span class="sd">    start_date.</span>
<span class="sd">    </span>
<span class="sd">    Missing values (NaN) are ignored in the averaging process.</span>
<span class="sd">    </span>
<span class="sd">    For DataFrames, only numeric columns are included in the output</span>
<span class="sd">        </span>
<span class="sd">    For DataArrays all attributes are preserved</span>
<span class="sd">        </span>
<span class="sd">    For Datasets</span>
<span class="sd">        - Variables without the time dimension are preserved unchanged</span>
<span class="sd">        - All attributes and encodings are preserved</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start_date</span> <span class="o">=</span> <span class="n">cftime</span><span class="o">.</span><span class="n">DatetimeNoLeap</span><span class="p">(</span><span class="n">start_year</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">time_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;time_column parameter is required for DataFrame input&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">computeAverageYear_DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">time_column</span><span class="p">,</span> <span class="n">start_date</span><span class="p">,</span> <span class="n">output_nyears</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">computeAverageYear_DataArray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">time_column</span><span class="p">,</span> <span class="n">start_date</span><span class="p">,</span> <span class="n">output_nyears</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
        <span class="c1"># Dataset can use custom time dimension name</span>
        <span class="n">time_dim</span> <span class="o">=</span> <span class="n">time_column</span> <span class="ow">or</span> <span class="n">time_column</span>
        <span class="k">return</span> <span class="n">computeAverageYear_Dataset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">start_date</span><span class="p">,</span> <span class="n">output_nyears</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input data must be a pandas DataFrame, xr DataArray, or xr Dataset. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<span class="c1">#</span>
<span class="c1"># Smooth data temporally</span>
<span class="c1">#</span>
<div class="viewcode-block" id="smoothTimeSeries_Array">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.smoothTimeSeries_Array">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">smoothTimeSeries_Array</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                           <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;savgol&#39;</span><span class="p">,</span> <span class="s1">&#39;rolling_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;savgol&#39;</span><span class="p">,</span>
                           <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                           <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smooth time series data using specified method.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : numpy.ndarray</span>
<span class="sd">        Array of data to smooth. Must not contain NaN values.</span>
<span class="sd">    method : {&#39;savgol&#39;, &#39;rolling_mean&#39;}</span>
<span class="sd">        Smoothing method to use.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which to smooth. Default is -1 (last axis).</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Method-specific parameters.</span>
<span class="sd">        </span>
<span class="sd">        For &#39;savgol&#39;:</span>
<span class="sd">            - window_length : int, odd number (default: 7)</span>
<span class="sd">            - polyorder : int (default: 3)</span>
<span class="sd">            - mode : str (default: &#39;interp&#39;)</span>
<span class="sd">            </span>
<span class="sd">        For &#39;rolling_mean&#39;:</span>
<span class="sd">            - window : int (default: 5)</span>
<span class="sd">            - center : bool (default: True)</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        Smoothed data array.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If method is not recognized, parameters are invalid, or data contains NaN.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check for NaN values</span>
    <span class="c1"># if np.any(np.isnan(data)):</span>
    <span class="c1">#     raise ValueError(&quot;Data contains NaN values&quot;)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;savgol&#39;</span><span class="p">:</span>
        <span class="c1"># Extract savgol parameters</span>
        <span class="n">window_length</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;window_length&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
        <span class="n">polyorder</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;polyorder&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="s1">&#39;interp&#39;</span><span class="p">)</span>

        <span class="c1"># Validate parameters</span>
        <span class="k">if</span> <span class="n">window_length</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;window_length must be odd for Savitzky-Golay filter&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">polyorder</span> <span class="o">&gt;=</span> <span class="n">window_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;polyorder must be less than window_length&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">window_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Data length along axis </span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="si">}</span><span class="s2">) must be &gt;= window_length (</span><span class="si">{</span><span class="n">window_length</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Apply Savitzky-Golay filter along specified axis</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">window_length</span><span class="p">,</span> <span class="n">polyorder</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;rolling_mean&#39;</span><span class="p">:</span>
        <span class="c1"># Extract rolling mean parameters</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;window&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Calculate origin for centering</span>
        <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">window</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Apply uniform filter (equivalent to rolling mean)</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">uniform_filter1d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                                              <span class="n">size</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                              <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                                              <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span>
                                              <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown smoothing method: </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="smoothTimeSeries_DataFrame">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.smoothTimeSeries_DataFrame">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">smoothTimeSeries_DataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
                               <span class="n">time_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span>
                               <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;savgol&#39;</span><span class="p">,</span> <span class="s1">&#39;rolling_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;savgol&#39;</span><span class="p">,</span>
                               <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smooth time series data in a DataFrame along the time dimension.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pandas.DataFrame</span>
<span class="sd">        Input DataFrame with time series data. Must not contain NaN values</span>
<span class="sd">        in columns to be smoothed.</span>
<span class="sd">    time_column : str</span>
<span class="sd">        Name of the time column.</span>
<span class="sd">    method : {&#39;savgol&#39;, &#39;rolling_mean&#39;}, optional</span>
<span class="sd">        Smoothing method. Default is &#39;savgol&#39;.</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Method-specific parameters passed to smoothing function.</span>
<span class="sd">        </span>
<span class="sd">        For &#39;savgol&#39;:</span>
<span class="sd">            - window_length : int, odd number (default: 7)</span>
<span class="sd">            - polyorder : int (default: 3)</span>
<span class="sd">            - mode : {&#39;mirror&#39;, &#39;constant&#39;, &#39;nearest&#39;, &#39;wrap&#39;, &#39;interp&#39;} (default: &#39;interp&#39;)</span>
<span class="sd">            </span>
<span class="sd">        For &#39;rolling_mean&#39;:</span>
<span class="sd">            - window : int (default: 5)</span>
<span class="sd">            - center : bool (default: True)</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        DataFrame with smoothed data.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If any column to be smoothed contains NaN values.</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Savitzky-Golay filter is useful for smoothing noisy data while preserving</span>
<span class="sd">    important features like peaks. The rolling mean provides simple moving average</span>
<span class="sd">    smoothing.</span>
<span class="sd">    </span>
<span class="sd">    Data is sorted by time before smoothing to ensure correct temporal ordering.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">time_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column &#39;</span><span class="si">{</span><span class="n">time_column</span><span class="si">}</span><span class="s2">&#39; not found in DataFrame&quot;</span><span class="p">)</span>

    <span class="c1"># Make a copy and sort by time</span>
    <span class="n">df_sorted</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">time_column</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Identify columns to smooth</span>
    <span class="n">numeric_cols</span> <span class="o">=</span> <span class="n">df_sorted</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">columns_to_smooth</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">numeric_cols</span> <span class="k">if</span> <span class="n">col</span> <span class="o">!=</span> <span class="n">time_column</span><span class="p">]</span>

    <span class="c1"># Apply smoothing to each column</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">df_sorted</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns_to_smooth</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">df_sorted</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">result</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">smoothTimeSeries_Array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="smoothTimeSeries_DataArray">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.smoothTimeSeries_DataArray">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">smoothTimeSeries_DataArray</span><span class="p">(</span><span class="n">da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
                               <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span>
                               <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;savgol&#39;</span><span class="p">,</span> <span class="s1">&#39;rolling_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;savgol&#39;</span><span class="p">,</span>
                               <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smooth time series data in a DataArray along the time dimension.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    da : xr.DataArray</span>
<span class="sd">        Input DataArray with time series data. Must not contain NaN values.</span>
<span class="sd">    time_dim : str, optional</span>
<span class="sd">        Name of the time dimension. Default is &#39;time&#39;.</span>
<span class="sd">    method : {&#39;savgol&#39;, &#39;rolling_mean&#39;}, optional</span>
<span class="sd">        Smoothing method. Default is &#39;savgol&#39;.</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Method-specific parameters passed to smoothing function.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xr.DataArray</span>
<span class="sd">        DataArray with smoothed data. All attributes and coordinates are preserved.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If time dimension is not found or data contains NaN values.</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For multidimensional arrays, smoothing is applied along the time dimension</span>
<span class="sd">    for each combination of other dimensions (e.g., each spatial point).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">time_dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Data must have a &#39;</span><span class="si">{</span><span class="n">time_dim</span><span class="si">}</span><span class="s2">&#39; dimension&quot;</span><span class="p">)</span>

    <span class="c1"># Check for NaN values</span>
    <span class="c1"># if np.any(np.isnan(da.values)):</span>
    <span class="c1">#     raise ValueError(&quot;DataArray contains NaN values&quot;)</span>

    <span class="c1"># Get the axis number for time dimension</span>
    <span class="n">time_axis</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">time_dim</span><span class="p">)</span>

    <span class="c1"># Apply smoothing along time dimension in one pass</span>
    <span class="n">smoothed_data</span> <span class="o">=</span> <span class="n">smoothTimeSeries_Array</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">time_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># Create result DataArray</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">result</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">smoothed_data</span>

    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="smoothTimeSeries_Dataset">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.smoothTimeSeries_Dataset">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">smoothTimeSeries_Dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
                             <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span>
                             <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;savgol&#39;</span><span class="p">,</span> <span class="s1">&#39;rolling_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;savgol&#39;</span><span class="p">,</span>
                             <span class="n">variables</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smooth time series data in a Dataset along the time dimension.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ds : xr.Dataset</span>
<span class="sd">        Input Dataset with time series data. Variables to be smoothed must</span>
<span class="sd">        not contain NaN values.</span>
<span class="sd">    time_dim : str, optional</span>
<span class="sd">        Name of the time dimension. Default is &#39;time&#39;.</span>
<span class="sd">    method : {&#39;savgol&#39;, &#39;rolling_mean&#39;}, optional</span>
<span class="sd">        Smoothing method. Default is &#39;savgol&#39;.</span>
<span class="sd">    variables : list of str, optional</span>
<span class="sd">        Variables to smooth. If None, smooths all variables with the time dimension.</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Method-specific parameters passed to smoothing function.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xr.Dataset</span>
<span class="sd">        Dataset with smoothed data. Variables without the time dimension are</span>
<span class="sd">        preserved unchanged. All attributes are preserved.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If time dimension is not found, specified variables don&#39;t exist,</span>
<span class="sd">        or any variable to be smoothed contains NaN values.</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Variables without the time dimension are copied unchanged to the output.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">time_dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Data must have a &#39;</span><span class="si">{</span><span class="n">time_dim</span><span class="si">}</span><span class="s2">&#39; dimension&quot;</span><span class="p">)</span>

    <span class="c1"># Select variables to smooth</span>
    <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vars_to_smooth</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">data_vars</span> <span class="k">if</span> <span class="n">time_dim</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Validate variables</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">data_vars</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Variables not found in Dataset: </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Only smooth variables that have time dimension</span>
        <span class="n">vars_to_smooth</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span> <span class="k">if</span> <span class="n">time_dim</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">]</span>

        <span class="c1"># Warn about variables without time dimension</span>
        <span class="n">no_time</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span> <span class="k">if</span> <span class="n">time_dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">no_time</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Variables without &#39;</span><span class="si">{</span><span class="n">time_dim</span><span class="si">}</span><span class="s2">&#39; dimension will not be smoothed: </span><span class="si">{</span><span class="n">no_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Create result dataset</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Smooth each variable</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">vars_to_smooth</span><span class="p">:</span>
        <span class="n">result</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">smoothTimeSeries_DataArray</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">],</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>



<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">smoothTimeSeries</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
                     <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
                     <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;savgol&#39;</span><span class="p">,</span> <span class="s1">&#39;rolling_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">smoothTimeSeries</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
                     <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
                     <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;savgol&#39;</span><span class="p">,</span> <span class="s1">&#39;rolling_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">smoothTimeSeries</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
                     <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
                     <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;savgol&#39;</span><span class="p">,</span> <span class="s1">&#39;rolling_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="smoothTimeSeries">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.smoothTimeSeries">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">smoothTimeSeries</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">],</span>
                     <span class="n">time_dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span>
                     <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;savgol&#39;</span><span class="p">,</span> <span class="s1">&#39;rolling_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;savgol&#39;</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smooth time series data using specified method.</span>
<span class="sd">    </span>
<span class="sd">    This function automatically selects the appropriate implementation based on the</span>
<span class="sd">    input data type: DataFrame, DataArray, or Dataset.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : pandas.DataFrame, xr.DataArray, or xr.Dataset</span>
<span class="sd">        Input data with time series. Must not contain NaN values in data to be smoothed.</span>
<span class="sd">    time_dim : str, optional</span>
<span class="sd">        For DataFrame: Name of the time column (required).</span>
<span class="sd">        For DataArray: Ignored.</span>
<span class="sd">        For Dataset: Ignored (use time_dim instead).</span>
<span class="sd">    method : {&#39;savgol&#39;, &#39;rolling_mean&#39;}, optional</span>
<span class="sd">        Smoothing method. Default is &#39;savgol&#39;.</span>
<span class="sd">    time_dim : str, optional</span>
<span class="sd">        For DataArray/Dataset: Name of time dimension (default: &#39;time&#39;).</span>
<span class="sd">        For DataFrame: Ignored (use time_dim instead).</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Method-specific parameters:</span>
<span class="sd">        </span>
<span class="sd">        For &#39;savgol&#39;:</span>
<span class="sd">            - window_length : int, odd number (default: 7)</span>
<span class="sd">            - polyorder : int (default: 3)</span>
<span class="sd">            - mode : {&#39;mirror&#39;, &#39;constant&#39;, &#39;nearest&#39;, &#39;wrap&#39;, &#39;interp&#39;} (default: &#39;interp&#39;)</span>
<span class="sd">            </span>
<span class="sd">        For &#39;rolling_mean&#39;:</span>
<span class="sd">            - window : int (default: 5)</span>
<span class="sd">            - center : bool (default: True)</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame, xr.DataArray, or xr.Dataset</span>
<span class="sd">        Same type as input with smoothed data.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If data is not a DataFrame, DataArray, or Dataset.</span>
<span class="sd">        If DataFrame is provided without time_dim.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If time column/dimension is not found.</span>
<span class="sd">        If data contains NaN values.</span>
<span class="sd">        If smoothing parameters are invalid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">smoothTimeSeries_DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
        <span class="c1"># DataArray uses time_dim parameter</span>
        <span class="k">return</span> <span class="n">smoothTimeSeries_DataArray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">smoothTimeSeries_Dataset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">time_dim</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input data must be a pandas DataFrame, xr DataArray, or xr Dataset. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<span class="c1">#</span>
<span class="c1"># 2D smoothing of dataset</span>
<span class="c1">#</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_smooth2D_Array</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                    <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;uniform&#39;</span><span class="p">,</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">,</span> <span class="s1">&#39;box&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply 2D spatial smoothing to data.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : numpy.ndarray</span>
<span class="sd">        3D or higher array where the last two dimensions are spatial.</span>
<span class="sd">        Must not contain NaN values.</span>
<span class="sd">    method : {&#39;uniform&#39;, &#39;gaussian&#39;, &#39;box&#39;}</span>
<span class="sd">        Smoothing method to use.</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Method-specific parameters:</span>
<span class="sd">        </span>
<span class="sd">        For &#39;uniform&#39;:</span>
<span class="sd">            - size : int or tuple of int (default: 3)</span>
<span class="sd">              Filter size in pixels. If int, same size for both dimensions.</span>
<span class="sd">              </span>
<span class="sd">        For &#39;gaussian&#39;:</span>
<span class="sd">            - sigma : float or tuple of float (default: 1.0)</span>
<span class="sd">              Standard deviation of Gaussian kernel. If float, same for both dimensions.</span>
<span class="sd">            - truncate : float (default: 4.0)</span>
<span class="sd">              Truncate filter at this many standard deviations.</span>
<span class="sd">              </span>
<span class="sd">        For &#39;box&#39;:</span>
<span class="sd">            - kernel_size : int or tuple of int (default: 3)</span>
<span class="sd">              Size of box filter. If int, same size for both dimensions.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        Smoothed data array with same shape as input.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If method is not recognized or data contains NaN.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check for NaN values</span>
    <span class="c1"># if np.any(np.isnan(data)):</span>
    <span class="c1">#     raise ValueError(&quot;Data contains NaN values&quot;)</span>

    <span class="c1"># Ensure we have at least 2D data</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data must be at least 2D for spatial smoothing&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
        <span class="c1"># Uniform filter (moving average)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

        <span class="c1"># Apply uniform filter to last two dimensions</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">uniform_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
        <span class="c1"># Gaussian filter</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sigma&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">truncate</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;truncate&#39;</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>

        <span class="c1"># Apply Gaussian filter to last two dimensions</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                                             <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span>
                                             <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
                                             <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span>
                                             <span class="n">truncate</span><span class="o">=</span><span class="n">truncate</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;box&#39;</span><span class="p">:</span>
        <span class="c1"># Box filter (simple averaging)</span>
        <span class="n">kernel_size</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;kernel_size&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">kernel_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">kernel_size</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">)</span>

        <span class="c1"># Create box kernel</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">)</span>

        <span class="c1"># For higher dimensional data, we need to apply 2D convolution along last two axes</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">convolve2d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;symm&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Process along last two dimensions for each slice</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="c1"># Iterate over all but the last two dimensions</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]):</span>
                <span class="n">result</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">convolve2d</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                                                      <span class="n">kernel</span><span class="p">,</span>
                                                      <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span>
                                                      <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;symm&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown smoothing method: </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_findSpatialDims</span><span class="p">(</span><span class="n">dims</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find spatial dimensions in a list of dimension names.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dims : tuple of str</span>
<span class="sd">        Dimension names to search.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dim1, dim2 : str</span>
<span class="sd">        Names of the two spatial dimensions.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If suitable spatial dimensions cannot be found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># First try x and y</span>
    <span class="k">if</span> <span class="s1">&#39;x&#39;</span> <span class="ow">in</span> <span class="n">dims</span> <span class="ow">and</span> <span class="s1">&#39;y&#39;</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span>

    <span class="c1"># Then try lon and lat</span>
    <span class="k">if</span> <span class="s1">&#39;lon&#39;</span> <span class="ow">in</span> <span class="n">dims</span> <span class="ow">and</span> <span class="s1">&#39;lat&#39;</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span>

    <span class="c1"># Also try longitude and latitude</span>
    <span class="k">if</span> <span class="s1">&#39;longitude&#39;</span> <span class="ow">in</span> <span class="n">dims</span> <span class="ow">and</span> <span class="s1">&#39;latitude&#39;</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span>

    <span class="c1"># No standard spatial dimensions found</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not find spatial dimensions. Expected &#39;x&#39; and &#39;y&#39; or &#39;lon&#39; and &#39;lat&#39;. &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;Available dimensions: </span><span class="si">{</span><span class="n">dims</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="smooth2D_DataArray">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.smooth2D_DataArray">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">smooth2D_DataArray</span><span class="p">(</span><span class="n">da</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
                       <span class="n">dim1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">dim2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;uniform&#39;</span><span class="p">,</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">,</span> <span class="s1">&#39;box&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply 2D spatial smoothing to a DataArray.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    da : xr.DataArray</span>
<span class="sd">        Input DataArray with at least 2 spatial dimensions. Must not contain NaN values.</span>
<span class="sd">    dim1 : str, optional</span>
<span class="sd">        First spatial dimension. If None, will try to find &#39;x&#39; or &#39;lon&#39;.</span>
<span class="sd">    dim2 : str, optional</span>
<span class="sd">        Second spatial dimension. If None, will try to find &#39;y&#39; or &#39;lat&#39;.</span>
<span class="sd">    method : {&#39;uniform&#39;, &#39;gaussian&#39;, &#39;box&#39;}, optional</span>
<span class="sd">        Smoothing method. Default is &#39;gaussian&#39;.</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Method-specific parameters passed to smoothing function.</span>
<span class="sd">        </span>
<span class="sd">        For &#39;uniform&#39;:</span>
<span class="sd">            - size : int or tuple of int (default: 3)</span>
<span class="sd">            </span>
<span class="sd">        For &#39;gaussian&#39;:</span>
<span class="sd">            - sigma : float or tuple of float (default: 1.0)</span>
<span class="sd">            - truncate : float (default: 4.0)</span>
<span class="sd">            </span>
<span class="sd">        For &#39;box&#39;:</span>
<span class="sd">            - kernel_size : int or tuple of int (default: 3)</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xr.DataArray</span>
<span class="sd">        DataArray with smoothed spatial data. All attributes and coordinates</span>
<span class="sd">        are preserved.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If spatial dimensions are not found or data contains NaN values.</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The smoothing is applied in 2D to each slice along non-spatial dimensions.</span>
<span class="sd">    For example, if the data has dimensions (time, lat, lon), smoothing is</span>
<span class="sd">    applied to each time slice independently.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find spatial dimensions if not provided</span>
    <span class="k">if</span> <span class="n">dim1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dim2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">found_dim1</span><span class="p">,</span> <span class="n">found_dim2</span> <span class="o">=</span> <span class="n">_findSpatialDims</span><span class="p">(</span>
            <span class="p">[</span><span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">])</span>
        <span class="n">dim1</span> <span class="o">=</span> <span class="n">dim1</span> <span class="ow">or</span> <span class="n">found_dim1</span>
        <span class="n">dim2</span> <span class="o">=</span> <span class="n">dim2</span> <span class="ow">or</span> <span class="n">found_dim2</span>

    <span class="c1"># Validate dimensions exist</span>
    <span class="k">if</span> <span class="n">dim1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dimension &#39;</span><span class="si">{</span><span class="n">dim1</span><span class="si">}</span><span class="s2">&#39; not found in DataArray&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dim2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dimension &#39;</span><span class="si">{</span><span class="n">dim2</span><span class="si">}</span><span class="s2">&#39; not found in DataArray&quot;</span><span class="p">)</span>

    <span class="c1"># Check for NaN values</span>
    <span class="c1"># if np.any(np.isnan(da.values)):</span>
    <span class="c1">#     raise ValueError(&quot;DataArray contains NaN values&quot;)</span>

    <span class="c1"># Get indices of spatial dimensions</span>
    <span class="n">dim1_idx</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim1</span><span class="p">)</span>
    <span class="n">dim2_idx</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim2</span><span class="p">)</span>

    <span class="c1"># Transpose data so spatial dimensions are last</span>
    <span class="n">dims_order</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">dims</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">]</span>
    <span class="n">da_transposed</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">dims_order</span><span class="p">)</span>

    <span class="c1"># Apply smoothing</span>
    <span class="n">smoothed_data</span> <span class="o">=</span> <span class="n">_smooth2D_Array</span><span class="p">(</span><span class="n">da_transposed</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># Create result with same dimension order as input</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># Transpose back to original order</span>
    <span class="n">result_transposed</span> <span class="o">=</span> <span class="n">da_transposed</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">result_transposed</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">smoothed_data</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result_transposed</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">da</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="smooth2D_Dataset">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.smooth2D_Dataset">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">smooth2D_Dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
                     <span class="n">dim1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">dim2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;uniform&#39;</span><span class="p">,</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">,</span> <span class="s1">&#39;box&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">,</span>
                     <span class="n">variables</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply 2D spatial smoothing to variables in a Dataset.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ds : xr.Dataset</span>
<span class="sd">        Input Dataset with at least 2 spatial dimensions. Variables to be smoothed</span>
<span class="sd">        must not contain NaN values.</span>
<span class="sd">    dim1 : str, optional</span>
<span class="sd">        First spatial dimension. If None, will try to find &#39;x&#39; or &#39;lon&#39;.</span>
<span class="sd">    dim2 : str, optional</span>
<span class="sd">        Second spatial dimension. If None, will try to find &#39;y&#39; or &#39;lat&#39;.</span>
<span class="sd">    method : {&#39;uniform&#39;, &#39;gaussian&#39;, &#39;box&#39;}, optional</span>
<span class="sd">        Smoothing method. Default is &#39;gaussian&#39;.</span>
<span class="sd">    variables : list of str, optional</span>
<span class="sd">        Variables to smooth. If None, smooths all variables that have both</span>
<span class="sd">        spatial dimensions.</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Method-specific parameters passed to smoothing function.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xr.Dataset</span>
<span class="sd">        Dataset with smoothed spatial data. Variables without both spatial</span>
<span class="sd">        dimensions are preserved unchanged. All attributes are preserved.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If spatial dimensions are not found, specified variables don&#39;t exist,</span>
<span class="sd">        or any variable to be smoothed contains NaN values.</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Only variables that contain both spatial dimensions are smoothed. Other</span>
<span class="sd">    variables are copied unchanged to the output.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If no dimensions specified, let the first variable determine them</span>
    <span class="c1"># This ensures consistent dimension finding across all variables</span>
    <span class="k">if</span> <span class="n">dim1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dim2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Try to find dimensions from the Dataset&#39;s dims</span>
        <span class="c1"># This is just for early validation and consistency</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">found_dim1</span><span class="p">,</span> <span class="n">found_dim2</span> <span class="o">=</span> <span class="n">_findSpatialDims</span><span class="p">(</span>
                <span class="p">[</span><span class="n">ds</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">dims</span><span class="p">])</span>
            <span class="n">dim1</span> <span class="o">=</span> <span class="n">dim1</span> <span class="ow">or</span> <span class="n">found_dim1</span>
            <span class="n">dim2</span> <span class="o">=</span> <span class="n">dim2</span> <span class="ow">or</span> <span class="n">found_dim2</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># If we can&#39;t find them at Dataset level, the DataArray function</span>
            <span class="c1"># will try to find them or raise an appropriate error</span>
            <span class="k">pass</span>

    <span class="c1"># Select variables to smooth</span>
    <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Get all data variables - let smooth2DDataArray handle dimension checking</span>
        <span class="n">vars_to_process</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Validate specified variables exist</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">data_vars</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Variables not found in Dataset: </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">vars_to_process</span> <span class="o">=</span> <span class="n">variables</span>

    <span class="c1"># Create result dataset</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Process each variable</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">vars_to_process</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Try to smooth the variable</span>
            <span class="n">result</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">smooth2D_DataArray</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">],</span> <span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># If it fails because of missing dimensions, just skip this variable</span>
            <span class="k">if</span> <span class="s2">&quot;not found in DataArray&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">or</span> <span class="s2">&quot;Could not find spatial dimensions&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                <span class="c1"># Variable doesn&#39;t have the required dimensions, keep original</span>
                <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                    <span class="c1"># User specifically requested this variable, so warn them</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Variable &#39;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">&#39; does not have required spatial dimensions, skipping.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Some other error (like NaN values), re-raise</span>
                <span class="k">raise</span>

    <span class="k">return</span> <span class="n">result</span></div>



<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">smooth2D</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
             <span class="n">dim1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
             <span class="n">dim2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
             <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;uniform&#39;</span><span class="p">,</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">,</span> <span class="s1">&#39;box&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
             <span class="n">variables</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
    <span class="o">...</span>


<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">smooth2D</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
             <span class="n">dim1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
             <span class="n">dim2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
             <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;uniform&#39;</span><span class="p">,</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">,</span> <span class="s1">&#39;box&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
             <span class="n">variables</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
    <span class="o">...</span>


<div class="viewcode-block" id="smooth2D">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.smooth2D">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">smooth2D</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">],</span>
             <span class="n">dim1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">dim2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;uniform&#39;</span><span class="p">,</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">,</span> <span class="s1">&#39;box&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">,</span>
             <span class="n">variables</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply 2D spatial smoothing to data.</span>
<span class="sd">    </span>
<span class="sd">    This function automatically selects the appropriate implementation based on the</span>
<span class="sd">    input data type: DataArray or Dataset.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : xr.DataArray or xr.Dataset</span>
<span class="sd">        Input data with at least 2 spatial dimensions. Must not contain NaN values</span>
<span class="sd">        in data to be smoothed.</span>
<span class="sd">    dim1 : str, optional</span>
<span class="sd">        First spatial dimension. If None, will try to find &#39;x&#39; or &#39;lon&#39;.</span>
<span class="sd">    dim2 : str, optional</span>
<span class="sd">        Second spatial dimension. If None, will try to find &#39;y&#39; or &#39;lat&#39;.</span>
<span class="sd">    method : {&#39;uniform&#39;, &#39;gaussian&#39;, &#39;box&#39;}, optional</span>
<span class="sd">        Smoothing method. Default is &#39;gaussian&#39;.</span>
<span class="sd">    variables : list of str, optional</span>
<span class="sd">        For Dataset: Variables to smooth (default: all with both spatial dims).</span>
<span class="sd">        For DataArray: Ignored.</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Method-specific parameters:</span>
<span class="sd">        </span>
<span class="sd">        For &#39;uniform&#39;:</span>
<span class="sd">            - size : int or tuple of int (default: 3)</span>
<span class="sd">              Filter size in pixels.</span>
<span class="sd">              </span>
<span class="sd">        For &#39;gaussian&#39;:</span>
<span class="sd">            - sigma : float or tuple of float (default: 1.0)</span>
<span class="sd">              Standard deviation of Gaussian kernel.</span>
<span class="sd">            - truncate : float (default: 4.0)</span>
<span class="sd">              Truncate filter at this many standard deviations.</span>
<span class="sd">              </span>
<span class="sd">        For &#39;box&#39;:</span>
<span class="sd">            - kernel_size : int or tuple of int (default: 3)</span>
<span class="sd">              Size of box filter.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xr.DataArray or xr.Dataset</span>
<span class="sd">        Same type as input with spatially smoothed data.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If data is not a DataArray or Dataset.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If spatial dimensions are not found or data contains NaN values.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Smooth a DataArray with Gaussian filter:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; da = xr.DataArray(data, dims=[&#39;time&#39;, &#39;lat&#39;, &#39;lon&#39;])</span>
<span class="sd">    &gt;&gt;&gt; smoothed = smooth2D(da, method=&#39;gaussian&#39;, sigma=2.0)</span>
<span class="sd">    </span>
<span class="sd">    Smooth specific variables in a Dataset:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; ds = xr.Dataset({&#39;temp&#39;: da1, &#39;pressure&#39;: da2})</span>
<span class="sd">    &gt;&gt;&gt; smoothed = smooth2D(ds, variables=[&#39;temp&#39;], method=&#39;uniform&#39;, size=5)</span>
<span class="sd">    </span>
<span class="sd">    Use custom dimension names:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; smoothed = smooth2D(data, dim1=&#39;x_coord&#39;, dim2=&#39;y_coord&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&#39;variables&#39; parameter is ignored for DataArray input&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">smooth2D_DataArray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">smooth2D_Dataset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input data must be xr DataArray or Dataset. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="interpolateValues">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.interpolateValues">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">interpolateValues</span><span class="p">(</span><span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                      <span class="n">points_crs</span><span class="p">:</span> <span class="n">CRS</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">data</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
                      <span class="n">method</span><span class="p">:</span> <span class="n">InterpOptions</span> <span class="o">=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolate values from a 2D grid-based DataArray at given x, y or lat, lon points.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points : np.ndarray</span>
<span class="sd">        A (N, 2) array of coordinates. Each row should contain an (x, y) or (lon, lat) pair.</span>
<span class="sd">    points_crs : CRS</span>
<span class="sd">        A coordinate system for the points.</span>
<span class="sd">    data : xr.DataArray</span>
<span class="sd">        A DataArray with coordinates either (&#39;x&#39;, &#39;y&#39;) or (&#39;lon&#39;, &#39;lat&#39;).</span>
<span class="sd">    method : {&#39;linear&#39;, &#39;nearest&#39;, &#39;cubic&#39;}</span>
<span class="sd">        Interpolation method to use.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        A 1D array of interpolated values with length N.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If DataArray does not have suitable coordinates for interpolation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">array_crs</span> <span class="o">=</span> <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">from_xarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">points_crs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">array_crs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">watershed_workflow</span><span class="o">.</span><span class="n">warp</span><span class="o">.</span><span class="n">xy</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">points_crs</span><span class="p">,</span> <span class="n">array_crs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="p">{</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">}</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coords</span><span class="p">):</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">{</span> <span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">}</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coords</span><span class="p">):</span>
        <span class="n">coord_names</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DataArray must have coordinates (&#39;x&#39;, &#39;y&#39;) or (&#39;lon&#39;, &#39;lat&#39;)&quot;</span><span class="p">)</span>

    <span class="n">coords</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">({</span><span class="n">coord_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="p">(</span><span class="s2">&quot;points&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">coord_names</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="p">(</span><span class="s2">&quot;points&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)})</span>

    <span class="n">interpolated</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">interpolated</span><span class="o">.</span><span class="n">as_numpy</span><span class="p">()</span></div>



<div class="viewcode-block" id="imputeHoles2D">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.imputeHoles2D">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">imputeHoles2D</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">nodata</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;cubic&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolate values for missing data in rasters using scipy griddata.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : xarray.DataArray</span>
<span class="sd">        Input raster data with missing values to interpolate.</span>
<span class="sd">    nodata : Any, optional</span>
<span class="sd">        Value representing missing data. Default is numpy.nan.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        Interpolation method for scipy.interpolate.griddata.</span>
<span class="sd">        Valid options: &#39;linear&#39;, &#39;nearest&#39;, &#39;cubic&#39;. Default is &#39;cubic&#39;.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        Interpolated array with missing values filled.</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function may raise an error if there are holes on the boundary.</span>
<span class="sd">    The interpolation is performed using scipy.interpolate.griddata with</span>
<span class="sd">    the specified method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nodata</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span> <span class="o">==</span> <span class="n">nodata</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="c1">#get only the valid values</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">xx</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">yy</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>
    <span class="n">newarr</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">griddata</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="n">newarr</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="rasterizeGeoDataFrame">
<a class="viewcode-back" href="../../data.html#watershed_workflow.data.rasterizeGeoDataFrame">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rasterizeGeoDataFrame</span><span class="p">(</span><span class="n">gdf</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span>
                          <span class="n">column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                          <span class="n">resolution</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                          <span class="n">bounds</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">nodata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a GeoDataFrame to a rasterized DataArray based on a column&#39;s values.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gdf : geopandas.GeoDataFrame</span>
<span class="sd">        Input GeoDataFrame containing geometries and data.</span>
<span class="sd">    column : str</span>
<span class="sd">        Name of the column containing values to rasterize. Must be a numeric type.</span>
<span class="sd">    resolution : float</span>
<span class="sd">        Spatial resolution of the output raster in the units of the GeoDataFrame&#39;s CRS.</span>
<span class="sd">        This defines the size of each pixel.</span>
<span class="sd">    bounds : tuple of float, optional</span>
<span class="sd">        Bounding box as (minx, miny, maxx, maxy). If None, bounds are computed</span>
<span class="sd">        from the GeoDataFrame&#39;s total bounds.</span>
<span class="sd">    nodata : int or float, optional</span>
<span class="sd">        Value to use for pixels not covered by any geometry. If None, defaults</span>
<span class="sd">        to NaN for float columns and -999 for integer columns.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xarray.DataArray</span>
<span class="sd">        Rasterized data with dimensions (&#39;y&#39;, &#39;x&#39;) and coordinates defined by</span>
<span class="sd">        the spatial extent and resolution. Areas outside geometries are set to</span>
<span class="sd">        the nodata value. The data type matches the column&#39;s data type.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If column is not found in the GeoDataFrame.</span>
<span class="sd">        If column is not numeric type.</span>
<span class="sd">        If GeoDataFrame is empty.</span>
<span class="sd">        If resolution is not positive.</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The function uses rasterio&#39;s rasterization capabilities to burn geometries</span>
<span class="sd">    into a raster. When geometries overlap, the value from the last geometry</span>
<span class="sd">    in the GeoDataFrame is used.</span>
<span class="sd">    </span>
<span class="sd">    The output DataArray includes the CRS information in its attributes if</span>
<span class="sd">    the GeoDataFrame has a CRS defined.</span>
<span class="sd">    </span>
<span class="sd">    The dtype of the output array matches the dtype of the input column.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># reset the index to make &#39;index&#39; a column if that is what is</span>
    <span class="c1"># requested to be colored.</span>
    <span class="k">if</span> <span class="n">column</span> <span class="o">==</span> <span class="s1">&#39;index&#39;</span><span class="p">:</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

    <span class="c1"># Validate inputs</span>
    <span class="k">if</span> <span class="n">column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column &#39;</span><span class="si">{</span><span class="n">column</span><span class="si">}</span><span class="s2">&#39; not found in GeoDataFrame&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;GeoDataFrame is empty&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">resolution</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Resolution must be positive, got </span><span class="si">{</span><span class="n">resolution</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Determine output data type and fill value</span>
    <span class="n">out_dtype</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>

    <span class="c1"># Set nodata value based on dtype if not provided</span>
    <span class="n">fill_value</span> <span class="o">=</span> <span class="n">out_dtype</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">nodata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">out_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">999</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">out_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column &#39;</span><span class="si">{</span><span class="n">column</span><span class="si">}</span><span class="s2">&#39; must be numeric type, got </span><span class="si">{</span><span class="n">out_dtype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">out_dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">nodata</span><span class="p">)</span>

    <span class="c1"># Validate geometry types and create a mask of geometry that are</span>
    <span class="c1"># valid and values that are not na</span>
    <span class="n">valid_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">MultiPolygon</span><span class="p">)</span>
    <span class="n">valid_mask</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span> <span class="o">&amp;</span> \
        <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">is_valid</span> <span class="o">&amp;</span> \
        <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span> <span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">valid_types</span><span class="p">))</span>

    <span class="c1"># Get bounds</span>
    <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">total_bounds</span><span class="p">)</span>  <span class="c1"># minx, miny, maxx, maxy</span>

    <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="n">bounds</span>

    <span class="c1"># Calculate raster dimensions</span>
    <span class="n">width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">maxx</span><span class="o">-</span><span class="n">minx</span><span class="p">)</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">))</span>
    <span class="n">height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">maxy</span><span class="o">-</span><span class="n">miny</span><span class="p">)</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">))</span>

    <span class="c1"># Create transform</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">from_bounds</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>

    <span class="c1"># Initialize array with nodata value</span>
    <span class="n">raster</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">out_dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">valid_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># No valid data to rasterize</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Create list of (geometry, value) pairs</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">geom</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                  <span class="k">for</span> <span class="n">geom</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">],</span> <span class="n">gdf</span><span class="p">[</span><span class="n">column</span><span class="p">][</span><span class="n">valid_mask</span><span class="p">])]</span>

        <span class="c1"># Rasterize</span>
        <span class="n">rasterio</span><span class="o">.</span><span class="n">features</span><span class="o">.</span><span class="n">rasterize</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span>
                                    <span class="n">out</span><span class="o">=</span><span class="n">raster</span><span class="p">,</span>
                                    <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
                                    <span class="n">fill</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                                    <span class="n">dtype</span><span class="o">=</span><span class="n">out_dtype</span><span class="p">)</span>

    <span class="c1"># Create coordinate arrays</span>
    <span class="c1"># X coordinates (cell centers)</span>
    <span class="n">x_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">minx</span> <span class="o">+</span> <span class="n">resolution</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">maxx</span> <span class="o">+</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">resolution</span><span class="p">)[:</span><span class="n">width</span><span class="p">]</span>
    <span class="c1"># Y coordinates (cell centers) - note that y decreases as row index increases</span>
    <span class="n">y_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">maxy</span> <span class="o">-</span> <span class="n">resolution</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">miny</span> <span class="o">-</span> <span class="n">resolution</span><span class="p">,</span> <span class="o">-</span><span class="n">resolution</span><span class="p">)[:</span><span class="n">height</span><span class="p">]</span>

    <span class="c1"># Create DataArray</span>
    <span class="n">da</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">raster</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">coords</span><span class="o">=</span><span class="p">{</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">x_coords</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">y_coords</span> <span class="p">},</span> <span class="n">name</span><span class="o">=</span><span class="n">column</span><span class="p">)</span>

    <span class="c1"># Add attributes</span>
    <span class="n">da</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;resolution&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">resolution</span>
    <span class="n">da</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;source_column&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">column</span>
    <span class="n">da</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>

    <span class="c1"># Add CRS if available</span>
    <span class="k">if</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">da</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;crs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">da</span></div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2019-202X, UT Battelle, Ethan Coon.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>